#  ==介绍==

## 1. 概念

jquery是javascript的一个实用库，如果想要使用必须先引入jquery才能够使用里面各种各样的方法

当引入jquery之后， 会向全局暴露一个$ , 函数， 所以我们书写的所有jquery语句都是以,  开头， jquery里面有很多方法， 我们可以接着打点调用其它方法

官网: [www.jquery.com](http://www.jquery.com);

里面的logo和slogan(口号): 写更少的代码,做更多的事情

jQquery的哲学: `简化DOM开发, 为兼容而生`!

jQuery统一了不同浏览器之间的DOM操作的差异，让我们可以简单地对DOM进行操作

## 2. 历史

详细请看 张大神 ： [jQuery诞生记-原理与机制](<https://www.zhangxinxu.com/wordpress/2013/07/jquery-%E5%8E%9F%E7%90%86-%E6%9C%BA%E5%88%B6/>)

## 3. 版本问题

jQuery的最新版本是3.1.0，不兼容IE6、7、8

 我们学习的是jQuery1.12.3，兼容IE6、7、8的，更符合中国的实际情况

 jQuery3和jQuery1.12.3的API完全一样

## 4. 引包

jquery是 `javascript`的一个实用库

引入的jquery的 script标签不能和书写 jquery语句的 script 标签是同一个, 可能冲突覆盖

```
<!-- 引入jquery -->
<script type="text/javascript" src="js/jquery-1.12.3.min.js"></script>
<script type="text/javascript">
// 在这里面可以书写所有的jquery语句
</script>
```

## 5. 特性

```
  // 获取元素
  $("#BOX ul li.teshu a").css("color","red");
  
  // 简化元素的运动
  $("p").animate({"left": 500}, 1000);
      
  // jquery都是批量操作的,所以不用使用for循环了
  $("p").css("background-color","green");
```

+ 简化了元素的选择,直接使用 css 选择器即可选中元素

+ jquery都是批量操作的,不管是添加时间还是修改样式,都是批量的,所以可以不用for循环语句

+ jquery简化了 dom 开发, 比如添加, 删除, 或者是 修改节点.

+ jquery 都是兼容的,不需要进行能力检测

## 6. 函数写法

在最初引入jquery的时候， 向全局暴露的不是$ 函数，是jQuery函数， 但是后来人们觉得书写起来比较复杂， 所以将jQuery函数修改为 函数，但是jQuery函数仍然保留，所以可以继续使用

```
// jQuery函数
jQuery("p").css("background-color", "blue");
```

# ==对比原生js==

## 1. 获取差异

- `js `获取方式

```
var a = document.getElementsByTagName("p")[0]
//这时 p 选中的是所有以 p 为根目标的所有 P元素 ,[]可以选中其中的哪一个
console.log(a.innerHTML)
// innerHTML 是对象的属性, 不是方法
```

- `jquery` 获取方式

```
$(".teshu").html("今天是个好日子")
```

`js`原生获取的`dom`是一个对象，`jQuery`对象就是一个数组对象，其实就是选择出来`元素的数组集合`。所以说他们两者是不同的对象类型不等价。

## 2. 互相转换

- 因为 `jquery`对象是元素组成的数组对象，数组对象自然不能调用原生的方法，但是能此数组对象能调用`jquery`自身的方法。
  - 通过属性访问器`[index]` 返回的是元素对象, 就可以使用`js` 原生属性和方法了。
  - 通过`.get(index)`方法。

- 原生对象里面没有`jquery`对象封装的属性和方法，所以需要互相转换。
  - `$ 包裹`是`jquery`独有的, 给`对象（变量名等）`包裹就可以转换为`jquery`。

```
// jquery转为js: 直接使使用 []
$("p")[0].innerHTML = "哈哈";
$("p")[1].innerHTML = "哈哈1";
$("p")[2].innerHTML = "哈哈2";

// js转为jquery: 直接使用$包裹 变量a 
$(a).html("666")
```

# ==选择器==

## 1. css2.1选择器

```
$(".box").css("color", "red");
$("#box").css("color", "blue");
$("div").css("color", "orange");
$("div, h3").css("color", "yellow");
$(".box1 ul li").css("color", "gray");
$("div.box1").css("color", "red");
```

## 2. css3 选择器

特殊情况:  eq ()方法,可以出现负数索引值

```
//第一个
$("p:first").css("background-color", "red");
//最后一个
$("p:last").css("background-color", "blue");
//等于多少
$("p:eq(2)").css();
    // 衍生的方法
    $("p").eq(2).css();
// 大于多少
$("p:gt(2)").css();
// 小于多少
$("p:lt(2)").css();
// 奇数
$("p:odd").css();
// 偶数
$("p:even").css()
```

# ==绑定事件==

## 1. 第一种方式

 $(dom).on(type, fn)

`此方法原生也可以用，不是jquery独有`

| 参数             | 返回值 |
| ---------------- | ------ |
| type，事件类型   |        |
| fn，要执行的函数 |        |

```
// 第一种绑定事件的方式
$("#btn").on("click", function() {
    // css的特殊用法 +=
    $("p").css("width", "+=30px");
})
```

## 2. 第二种方式

一般用这种方式, 更加方便，这是`jq独有的方法`

$(dom).click(fn)

| 参数             | 返回值 |
| ---------------- | ------ |
| fn，要执行的函数 |        |

```
// 第二种绑定事件的方式
$("#btn").click(function() {
    // css的特殊用法 +=
    $("p").css("width", "+=30px");
})
```

# ==常用方法==

## 1. size 元素个数

| 参数 | 返回值                   | 兼容性                     |
| ---- | :----------------------- | :------------------------- |
| 空   | 元素对象个数，Number类型 | 新版本jq不支持此方法，报错 |

```
// 想要获取所有p元素的个数
console.log($("p").size());  // 不可用，报错

// 常用的方式是 length
console.log($("p").length);
```

jq最新版只有 length 属性，不是方法

## 2. css 获取设置计算后属性

| 参数                         | 返回值                  |
| :--------------------------- | :---------------------- |
| 读取的计算后的样式/属性      | 读取属性值，String类型  |
| 要设置对应的属性值，单一属性 | jQuery.fn.init 内置对象 |
| json {k: v}，多个属性        | jQuery.fn.init 内置对象 |

```
// js原生方式获取元素
var a = document.getElementById("box").getElementsByTagName("p")[0]

a.style.color = "red"

// jq方式获取元素
$("p:first").css("color", "green")

// css设置多个属性
$("p:first").css({
    "font-size": 16,
    "line-height": "24px"
})

// size方法
// $("p").size()  // 新版本jq删除了此方法


// 点击变大 1
$("input").click(function () {
    $(".teshu").css({
        "width": "+=20px"
    })
})

// 点击变大 2
$("input").on("click", function () {
    $(".teshu").css({
        "width": "+=20px"
    })
})
```

读取元素**计算后**的样式

当设置的属性值带有单位的时候，一定要加上双引号

没有带单位的时候， 不用添加双引号

所有样式 **强制设置在行内**

使用 json 参数,  json里面属性名,必须使用双引号包裹

## 3. attr 获取设置自带属性

| 参数         | 返回值                   |
| ------------ | ------------------------ |
| 获取的属性名 | 获取的属性值，String类型 |
| 修改的属性值 | jq内置对象               |

```
/**
* 需求:
* 		-当鼠标移入box中， 改变图片
* 		-当鼠标离开box的时候， 恢复原图
*/

// 当鼠标移入box中， 改变图片
$("#box").mouseenter(function() {
    $("img").attr("src", "images/aoyun/1.jpg");
});

// 鼠标离开恢复原图
$("#box").mouseleave(function() {
    $("img").attr("src", "images/aoyun/0.jpg");
});

// 传递一个参数, 表示读取
console.log($("#box").attr("id"));
```

attr(key, value) 属性名, 属性值

可以设置元素的原有属性,可以理解为 修改元素属性的值

## 4. show/hide 出现隐藏

|           | 参数         | 返回值                  | 兼容     |
| --------- | ------------ | ----------------------- | -------- |
| show ()   | 空，干嘣效果 | jQuery.fn.init 内置对象 | 淡出     |
| hide ()   | 自定义时间   | jQuery.fn.init 内置对象 | 慢慢合并 |
| toggle () | 自定义时间   | jQuery.fn.init 内置对象 | 切换     |

```
// 点击出现
$("button").eq(0).click(function () {
    $("p").show(1000) // 不写参数，干嘣效果
})

// 点击隐藏
$("button").eq(1).click(function () {
    $("p").hide(1000)
})

// 互相切换
$("button").eq(2).click(function () {
    $("p").toggle(1000)
})
```

+ **show()** :  只有当元素的状态是display: none的时候才可以调用， 最终状态是display: block
+ **hide() **: 只有当元素的转态是display: block的时候才可以调用， 最终状态是display: none

## 5. slideDown/Up 展开合并 

|                | 参数                  | 返回值                  | 兼容     |
| -------------- | --------------------- | ----------------------- | -------- |
| slideDown ()   | 空，默认400ms动画效果 | jQuery.fn.init 内置对象 | 慢慢展开 |
| slideUp ()     | 自定义时间            | jQuery.fn.init 内置对象 | 慢慢合并 |
| slideToggle () | 自定义时间            | jQuery.fn.init 内置对象 | 切换     |

```
// 点击慢慢展开
$("button").eq(0).click(function () {
    $("p").slideDown(1000)
})

// 点击慢慢合并
$("button").eq(1).click(function () {
    $("p").slideUp(1000)
})

// 互相切换
$("button").eq(2).click(function () {
    $("p").slideToggle(1000)
})
```

- 只有当元素的状态是 **display: none** 的时候才可以调用 slideDown ()， 当调用该方法的时候， 元素的height瞬间变为0， 然后以动画的形式慢慢的变到元素的初始height， 最终的状态仍然是display: block

- 只有当元素的状态是 **display: block** 的时候才可以调用 slideUp (), height 慢慢变为 0,  最终的状态仍然是display: none

- slideDown/up 不一定是一个方向运动, 而是根据自身的父元素边界来决定向上动画还是向下动画

## 6. fadeIn/Out 淡入淡出 

|               | 参数                   | 返回值                  | 兼容       |
| ------------- | ---------------------- | ----------------------- | ---------- |
| fadeIn ()     | 空，默认400ms动画效果  | jQuery.fn.init 内置对象 | 淡出       |
| fadeOut ()    | 自定义时间             | jQuery.fn.init 内置对象 | 淡入       |
| fadeToggle () | 自定义时间             | jQuery.fn.init 内置对象 | 切换       |
| fadeTo()      | 自定义时间和设置透明度 | jQuery.fn.init 内置对象 | 指定透明度 |

```
// 点击出现
$("button").eq(0).click(function () {
	$("p").fadeIn(1000)
})

// 点击隐藏
$("button").eq(1).click(function () {
	$("p").fadeOut(1000)
})

// 互相切换
$("button").eq(2).click(function () {
	$("p").fadeToggle(1000)
})

// 指定透明度
$("button").eq(3).click(function () {
	$("p").fadeTo(1000, .6)
})
```

- **faleIn ()**:  只有当元素的状态是 **display: none** 的时候才可以调用， 当调用该方法的时候，元素的opacity值瞬间变为0， 然后以动画的形式慢慢变到opacity: 1，最终是display: block的状态
- **fadeOut ()** : 只有当元素的状态是 **display: block** 的时候才可以调用, opacity 慢慢变为 0,  最终的状态仍然是display: none
- **fadeTo ():**  元素任何状态都可以运行，透明度可以保留

## 7. addClass/removeClass 添加删除类名

|                | 参数     | 返回值                  |
| -------------- | -------- | ----------------------- |
| addClass ()    | 添加类名 | jQuery.fn.init 内置对象 |
| removeClass () | 删除类名 | jQuery.fn.init 内置对象 |

参数使用双引号包裹

## 8. html 文本操作

| 参数                           | 返回值                         |
| ------------------------------ | ------------------------------ |
| 空                             | 获取元素的内部文本，String类型 |
| “字符串“，改变文本，原来的改变 | jQuery.fn.init 内置对象        |
| 标签，改变节点，原来的改变     | jQuery.fn.init 内置对象        |

```
<!-- DOM 结构 -->
<div class="box" id="box">好嗨呦</div>
<div id="box1"></div>
```

```
// 想要获取元素的内部文本
console.log($("#box").html());

// 改变div中的内部文本
$("#box").html("哥， 你好帅哟");

// 使用html添加节点
$("#box1").html("<ul><li>123</li></ul>");
```

## 9. 获取用户输入的内容

$( this ).val()

# ==节点操作==

> $(function () {console.log(123)}) ： DOM结构加载完再加载
>
> windown.onload = function () {console.log(123)} ： 所有的资源加载完之后再加载
>
> 所以 $(function () {console.log(123)})比 windown.onload = function () {console.log(123)},快

## 1. 节点定义

节点就是 html 中的元素, 也叫元素节点

js 原生获取元素节点要先经过 document ,  在 jquery 中使用 $ 函数直接选中元素节点,  很方便

- 特殊对象

在 jquery 中有三个对象是不需要添加 双引号的

```
$(this)
$(document)
$(window)
```

## 2. 读取节点

### parent 父节点

| 参数 | 返回值                                   |
| ---- | ---------------------------------------- |
| 空   | 父元素对象 ，不会选中爷爷，  Object 类型 |

```
// 点击哪个p就让哪个p元素的父节点背景色改变
$("p").click(function() {
    $(this).parent().css("background-color", "red");
});
```

### siblings 兄弟节点

| 参数           | 返回值                                  |
| -------------- | --------------------------------------- |
| 空或者指定兄弟 | 同一父元素下面的兄弟对象 ,  Object 类型 |

```
// 当点击哪个div的时候就让哪个div的兄弟节点背景色改变
$("div").click(function() {
	$(this).siblings().css("backgroundColor", "red");
});
```

### children 儿子节点

| 参数           | 返回值                                    |
| -------------- | ----------------------------------------- |
| 空或者指定儿子 | 子节点，直系后代，不会选孙子，Object 类型 |

```
// 当点击哪个div的时候就让哪个div的子节点背景色改变
$("div").click(function() {
	$(this).children().css("backgroundColor", "red");
});
```

### 其他

+ next ():   会选中下一个兄弟节点
+ nextAll ():   会选中后面所有的兄弟节点
+ prev ():   会选中上一个兄弟节点
+ prevAll ():   会选中前面所有的兄弟节点
+ parents ():   会选中祖先节点 ，参数可以书写指定哪个祖先
+ find ():   会选中所有的后代节点， 参数可以指定哪个后代

## 3. 创建节点

可以使用$函数的功能来创建一个元素，创建后要添加到 DOM tree上

```
$(“<div class=‘aaa’data-info=‘nihao’ id=‘box’>content</div>”)
```

## 4. 增加节点

### 父追子

- $dom.append () : 往dom的**后面**追加

- $dom.prepend () : 往dom的**前面**追加

| 参数         | 返回值     |
| ------------ | ---------- |
| 要增加的元素 | jq内置对象 |

### 子追父

- $dom.appendTo ()：将dom追加到父元素的**后面**

- $dom.prependTo ()：将dom追加到父元素的**前面**

| 参数         | 返回值     |
| ------------ | ---------- |
| 要增加的元素 | jq内置对象 |

### 自身追兄弟

- $dom.before ()：在dom的**前面**放入一个元素

- $dom.after ()：在dom的**后面**放入一个元素

| 参数         | 返回值     |
| ------------ | ---------- |
| 要增加的元素 | jq内置对象 |

## 5. 插入节点

- $dom.insertAfter ()：将dom插入到某个元素的**后面**

- $dom.insertBefore ()：将dom插入到某个元素的**前面**

| 参数     | 返回值     |
| -------- | ---------- |
| 参考节点 | jq内置对象 |

```
// 创建一个li元素
var $li = $("<li>888</li>");

// 将创建出来的li元素，插入到four的前面作为它的上一个兄弟节点存在
$li.insertBefore($("#four"));


// 将创建出来的li元素，插入到four的后面作为它的下一个兄弟节点存在
$li.insertAfter($("#four"));


// 在four的前面插入一个元素
$("#four").before("<div>呵呵我是一个div</div>");

// 在four的后面插入一个元素
$("#four").after("<p>哈哈我是一个p标签</p>");
```

## 6. 外套节点

- wrap ()：用于给匹配到的元素的外层添加一层元素

- wrapALL ()：用于给匹配到的 **所有元素** 的外层添加一层元素

| 参数         | 返回值     |
| ------------ | ---------- |
| 要增加的元素 | jq内置对象 |

```
// wrap 用于给匹配到的元素的外层添加一层元素
$("p").wrap("<div></div>")
```

```
// wrap 用于给匹配到的 “所有元素” 的外层添加一层元素
$("p").wrapALL("<div></div>");
```

## 7. 替换节点

- replaceWith ()  用于将匹配到的元素替换成指定的元素
- replaceAll ()   用于将指定的元素替换掉所匹配到的每一个元素

| 参数       | 返回值     |
| ---------- | ---------- |
| 被替换元素 | jq内置对象 |

```
// replaceWith 用于将匹配到的元素替换成指定的元素
$("p").replaceWith("<div>123</div>");


// replaceAll 用于将指定的元素替换掉所匹配到的每一个元素
$("<div>234</div>").replaceAll($("p"));
```

## 8. 删除节点

- empty ()：表示清空后代， 自己还在
- remove ()：表示 自杀,  自己和后代都没有了

| 参数         | 返回值     |
| ------------ | ---------- |
| 要增加的元素 | jq内置对象 |

```
// empty 表示清空后代， 自己还在
$(".box").empty();  // 输出  <div class="box"></div>
```

```
// remove 表示自杀， 自己和后代都没有了
$(".box").remove();   // 输出  在浏览器里面已经看不到 box元素了
```

## 9. 克隆节点

clone ()：克隆一个节点，js 原生的是 cloneNode ()

| 参数                              | 返回值       |
| --------------------------------- | ------------ |
| false，默认值；连同子节点一起复制 | 被克隆的对象 |
| true，连同事件也一起复制          | 被克隆的对象 |

```
/ 克隆box
$(".box").after($(".box").clone())
```

```
// 给box添加点击事件
$(".box").click(function() {
	alert(123);
});


// clone() 并且传递true
$(".box").after($(".box").clone(true));
```

# ==序号操作==

## 1. eq 索引对应的对象

| 参数                      | 返回值                             |
| ------------------------- | ---------------------------------- |
| index 索引值,  也就是数字 | 索引值对应的元素对象,  object 类型 |

等于,序号是index索引值, 表示选中元素的跨队列的排名, 亲兄弟没有直接关系, 选中元素的不同, 序号也是不同的

```
// dom
<div class="box">
<p></p>
<p class="teshu"></p>
<p class="teshu"></p>
<p></p>
</div>
<div class="box" id="box">
    <p></p>
    <p class="teshu"></p>
    <p class="teshu">我想要变红</p>
    <p></p>
</div>

// js
$(".teshu").eq(3).css("color", "red");
$("#box .teshu").eq(1).css("background-color", "blue");
$("p").eq(6).css("background-color", "red");
```

## 2. index 对象对应的索引值

| 参数                      | 返回值                     |
| ------------------------- | -------------------------- |
| 空正常，**写了只返回 -1** | 索引值排序 ,   number 类型 |

示亲兄弟的排名,只要是**同一个父节点**都是亲兄弟,而且不分元素区别,只看父节点.

```
// dom
<div class="box">
<ul>
	<li>123</li>
</ul>
<p></p>
<p></p>
<p></p>
<p>弹出亲兄弟的排名</p>
</div>

// js
<script type="text/javascript" src="js/jquery-1.12.3.min.js"></script>
<script type="text/javascript">
// 点击最后一个p弹出亲兄弟的排名
$("p").click(function() {
    console.log($(this).index());
});
</script>
```

# ==快捷尺寸==

## 1. 内容区

`.width()`

包含:  内容区

输出  number

```
console.log($(".box").width())
```

## 2. 内边距以内

`.innerWidth()`

包含:  内容区 + padding

输出  number

```
// content + pddding
console.log("innerWidth的宽是:", $("#box").innerWidth())
console.log("innerHeight的高是:", $("#box").innerHeight())
```

## 3. 边框以内

`.outerWidth()`

包含:  内容区 + padding + border

输出  number

```
// content + padding + border
console.log("outerWidth的宽度是:", $("#box").outerWidth())
console.log("outerHeight的高度是:", $("#box").outerHeight())
```

## 4. 边框内外

`.outerWidth(true)`

包含:  内容区 + padding + border + margin

输出  number

```
// content + padding + border + margin
console.log("outerWidth(true)的宽度是:", $("#box").outerWidth(true));
console.log("outerHeight(true)的高度是:", $("#box").outerHeight(true))
```

## 5. 定位值

`.position ()`

$(dom).position(), 返回一个对象， 对象中包含dom的定位left值以及dom的定位top值

```
// 获取box2的定位值
var $box2_position = $("#box2").position();
console.log($box2_position);
```

# ==each 遍历==

jq独有的方法，js原生没有

##1. 对象.each(fn)

| 参数                                                     | 返回值                  |
| -------------------------------------------------------- | ----------------------- |
| 空，会报错                                               |                         |
| fn 要执行的函数（index, value），里面有个i为每一项索引值 | jQuery.fn.init 内置对象 |

```
$(".teshu").each(function(i) {
    console.log(typeof $(this)); //输出 object
    console.log(i); // 输出的是 index 数值
});
```

```
// 实现隔列变色
$("tr").each(function() {
    $(this).children("td:odd").css("backgroundColor", "orange");
    $(this).children("td:even").css("backgroundColor", "lightblue");
});
```

## 2. $.each(target, fn)

| 参数                                                         | 返回值                  |
| ------------------------------------------------------------ | ----------------------- |
| target, 需要遍历的目标                                       | jQuery.fn.init 内置对象 |
| fn, 需要执行的函数（index, value），fn 必须有参数：index， value | jQuery.fn.init 内置对象 |

```
// 定义一个数组
var arr = ["red", "blue", "green", "yellow"];

// 使用each方法中的第二种方式
$.each(arr, function(index, value) {
	console.log(value); // 输出每一个成员
})
```

[Jquery Each函数补充——相关参数解释](https://www.cnblogs.com/pyspark/articles/8127412.html)

# ==animate 动画==

animate是基于终点的动画

| 参数                                     | 返回值                    |
| ---------------------------------------- | ------------------------- |
| Json {k:v, k:v}                          | -                         |
| time，完成动画的时间, 单位是 ms,一般省略 | 元素对象  ,   object 类型 |

```
// 让所有的p元素运动到500的位置  js
$("p").animate({"left": 500}, 2000);
```

## 1. 能够参与动画的属性

+ 所有数值型的属性都可以参与动画
+ width
+ height
+ border
+ borderRadius 是可以参与动画的

## 2. 不能参与动画的属性

+ backgroundColor
+ backgroundPosition
+ CSS3的一些复杂属性（transform）
+ 非数值类型的属性

## 3. 动画执行顺序

### 同一元素,不同animate参数

按照前后顺序执行动画的

```
// 添加第一段动画
$("p").animate({"left": 500}, 2000); //这个先执行

// 第二段动画
$("p").animate({"top": 500}, 2000); // 这个等待后执行
```

### 同一animate动画 ,  多属性

一个animate动画里面, 多属性是同时执行的

```
// 不等价于:  (这是一个动画,两个属性一起执行)
$("p").animate({
    "left": 500,
    "top": 500
}, 2000);
```

### 不同元素

都是同时执行

```
// 添加动画
$("p").animate({"left": 500}, 2000); // 这两个动画同时执行,不等待

// 给div添加动画
$("div").animate({"left": 500}, 2000); // 这两个动画同时执行,不等待
```

# ==回调函数==

## 1. 异步语句

类似于animate这种 **需要花费时间的语句**

如果后面还有其他的js语句， 这些语句 **不会死等着animate执行完毕之后，再去执行** ,  而回调函数是等其他语句执行完, 再去执行

```
animate(), show(), hide(), slideDown(), slidUp(), fadeIn(), fadeOut() 等这些都是异步语句
```

## 2. 回调函数

异步语句一般都有一个回调函数, 当异步语句执行完毕之后要做的事情就写在回调函数中

**语法:  异步语句的最后一个参数 , 这个参数是 函数 callBack**

```
// 让p元素运动完毕之后再去改变它的颜色
$("p").animate({"left": 1000}, 2000, function() {
	$(this).css("background-color", "red");
});
```

```
// 当div完全出现之后改变颜色
$("#box").show(2000, function() {
	$(this).css("background-color", "pink");
});

$("#box").fadeIn(2000, function() {
	$(this).css("background-color", "blue");
})
```

## 3. delay 延迟执行

| 参数                  | 返回值                   |
| --------------------- | ------------------------ |
| 要延迟的时间，单位 ms | 元素对象 ,   object 类型 |

表示延迟 , 延迟多长时间再执行动画

只有元素动画之前才可以调用, 也就是**异步语句都可以调用**

 利用 delay() 控制元素的进场顺序

```
// 遍历每一个p元素， 控制进场顺序
$("p").each(function(index) {
    // console.log(index); // 输出的是 索引值 1,2,3... number类型;
    $(this).delay(500 * index).show(0);
});
```

## 4. stop 停止动画

| 参数                                | 返回值     |
| ----------------------------------- | ---------- |
| 是否清空当前动画队列，默认 false    |            |
| 是否立即完成当前动画  ,   默认false | jq内置对象 |

让运动的元素立即停止动画

### stop(false, false)

默认方式 , 等价方式stop(),

立即进入下一个动画， 立即停止当前动画

### stop(false, true)

立即进入下一个动画， 立即停止并完成当前动画

### stop(true, true)

清空当前动画队列， 立即停止并完成当前动画

### stop(true, false)

清空当前动画队列， 立即停止当前动画

**一般使用这个** , 来清除动画积累

```
<!-- DOM 结构 -->
<button id="btn1">stop(false, false)</button>
<button id="btn2">stop(false, true)</button>
<button id="btn3">stop(true, true)</button>
<button id="btn4">stop(true, false)</button>

<div class="box"></div>

// 给元素添加4个动画
$(".box").animate({"left": 500}, 2000);
$(".box").animate({"top": 500}, 2000);
$(".box").animate({"left": 50}, 2000);
$(".box").animate({"top": 50}, 2000);

// stop(false,false)  1. 不清空当前动画队列; 2. 立即停止当前动画
$("#btn1").click(function () {
    $(".box").stop(false,false);
});

// stop(false,true)  1. 不清空当前动画队列; 2. 立即停止并完成当前动画
$("#btn2").click(function () {
    $(".box").stop(false,true);
});

// stop(true, true) 1. 清空当前动画队列; 2. 立即停止并完成当前动画
$("#btn3").click(function () {
    $(".box").stop(true,true);
});

//  stop(true, false) 1. 清空当前动画队列; 2. 立即停止当前动画
$("#btn4").click(function () {
    $(".box").stop(true, false);
});
```

## 5. is (":") 判断状态

is() 根据选择器、元素或 jQuery 对象来检测匹配元素集合，如果这些元素中至少有一个元素匹配给定的参数，则返回 true。

| 参数     | 返回值                                   |
| -------- | ---------------------------------------- |
| 元素名称 | true , 符合元素的状态 ;   false , 不符合 |

```
// 第一种写法
if ($(".box").is(":animated")) {
    // 运动的时候, 什么也不做
    return; // 跳出整个函数
}
// 后面写需要执行的语句 ...

// 第二种写法 加 逻辑非 !
if (!$(".box").is(":animated")) {
    //不运动的时候, 执行的语句写在这里
}
```

# ==防止动画积累==

## 1. 概述

一个元素身上可能存在多个动画事件,尤其是在不经意间添加的动画,这个时候就要防止(动画积累)

也就是短时间内多次点击等操作,  动画会一直执行完,

例子:  现在又一支去往广州的军队,中途又接到新的命令,回到北京, 这时候**有两个策略**

```
<!-- CSS -->
.box {
    position: absolute;
    width: 100px;
    height: 100px;
    background-color: pink;
    left: 50px;
    top: 50px;
}
<!-- DOM -->
<button id="btn1">回北京</button>
<button id="btn2">去广州</button>
```

## 2. 第一个策略

**利用 stop(true) 来实现:**  清空当前动画队列; 立即停止当前动画

```
// 给btn2添加点击事件， 让div运动到1000的位置
$("#btn2").click(function() {
    $(".box").stop(true).animate({"left": 1000}, 2000);
});
// 给btn1添加点击事件， 让div元素运动到50的位置
$("#btn1").click(function() {
    $(".box").stop(true).animate({"left": 50}, 2000);
});
```

## 3. 第二个策略

**is(":animated)**: 当元素在运动的时候返回 true, 当元素不运动的时候返回 false

```
// 当元素运动的时候不接受新的任务
$("#btn2").click(function() {
    if ($(".box").is(":animated")) {
        // 什么也不做
        return; // 跳出整个函数
    }
    // console.log($(".box").is(":animated"));
    
    $(".box").animate({"left": 1000}, 2000);
});
// 当元素不运动的时候，才接受新的任务
$("#btn1").click(function() {
    if (!$(".box").is(":animated")) {
        $(".box").animate({"left": 50}, 2000);
    }
});
```

# ==事件委托==

$(selector).on(type, fun); 该方法可以给选中的元素添加事件 

此时，只有两个参数，type表示事件类型 fun表示事件函数 此时真的是只给被选中元素添加该类型事件。

$(selector).on(type, selector, fun); 可以使用委托模式

type: 事件类型

selector: 子元素选择器

fun: 事件函数

此时，事件依旧绑定给被选中的元素$()里面的元素

但是，只有触发参数selector的该type事件时，才会触发fun的执行。

此时fun中的this，指向的就不是$()内的元素而是参数selector选中的元素。

# ==函数节流==

is(":") ,  stop ()这是jquery的方法,  原生 js不能使用。函数节流都能用，且更加灵活

对一些频繁触发的函数事件进行一些限制，可以使函数在规定的时间内或者是满足一定的条件之后再去执行

- 设置lock  取值是布尔值
- 如果 lock = true 函数可以执行的
- 如果lock = false 函数不可以执行

```
// 定义锁
var lock = true;
// 定义函数
function fun() {
  if (!lock) {
   return; 
}
  // 上锁
  lock = false;
    console.log(123);
}
  // 解锁
  lock = true
```

# ==setTimeout 延时器==

| 参数                                      | 返回值           |
| ----------------------------------------- | ---------------- |
| fn 要执行的函数                           |                  |
| time 要延迟的时间，单位 ms , 一般省略不写 | 设置几个返回数字 |

setTimeout(fn, time)  我们可以把延时器当做是一个定时炸弹， 在规定的时间内只会执行一次

配合函数节流使用情况: 

```
// 设置锁
var lock = true;
// 给btn添加点击事件
$("#btn").click(function() {
	// 函数节流
	if (!lock) {
		return;
	}
	// 关闭锁
	lock = false;
	console.log("函数执行了");

	// 开启延时器
	window.setTimeout(function() {
		// 3s之后开锁
		lock = true;
		console.log("延时3s");
	}, 3000);
})
```

# ==案例应用==

## 0. 选项卡

对应思想和序号操作的应用

```
/**
* 需求:
* 		当鼠标移入#hd span元素的时候， 让当前span加cur, 让下面#bd div对应的元素加上active
*
* 		1: 给#hd span 添加鼠标移入事件
* 		2: 让下面的div加上active
*/

// 添加鼠标移入事件 
$("#hd span").mouseenter(function() {
    // 当前sapn加cur
    $(this).addClass("cur");
    // 排他
    $(this).siblings().removeClass("cur");
    // 让对应的div加active
    $("#bd div").eq($(this).index()).addClass("active").siblings().removeClass("active");

	// 节点操作
	$(this).parent().siblings().children("div").eq($(this).index()).	addClass("active").siblings().removeClass("active");
});
```

下面是上面案例的简化写法 (连续打点) ,  推荐

```
/* 需求: 鼠标移入span元素的时候,让当前的span加上cur
    1.选中所有span元素, 添加鼠标移入事件
    2.当前span加cur
    3.对应div元素加active
    */

// 连续打点
$(".box .hd span").click(function () {
    $(this).addClass("cur").siblings().removeClass("cur").parent().siblings(".bd").children().eq($(this).index()).addClass("active").siblings().removeClass("active")
})
```

## 1. 呼吸轮播图

```
// 获取元素
var $imgs = $("#carousel .imgs li")
var length = $imgs.length
var $carousel = $("#carousel")
var $leftBtn = $("#carousel .btns .leftBtn")
var $rightBtn = $("#carousel .btns .rightBtn")
var $dt = $("#dt li")

// 定义信号量
var idx = 0

// 开启定时器
var timer = setInterval(change, 2000)

// 鼠标进入
$carousel.mouseenter(function () {
    // 清除定时器
    clearInterval(timer)
})

// 鼠标离开
$carousel.mouseleave(function () {
    // 再次清除定时器
    clearInterval(timer)
    // 开启定时器
    timer = setInterval(change, 2000)
})

// 右按钮点击事件
$rightBtn.click(change)

// 封装右按钮事件
function change() {
    // 防流氓
    if ($imgs.is(":animated")) {
        return
    }
    // 当前图片淡出
    $imgs.eq(idx).fadeOut(600)
    // 改变信号量
    idx ++
    // 判断信号量边界
    if (idx > length - 1) {
        idx = 0
    }
    // 下一张图片进入
    $imgs.eq(idx).fadeIn(600)
    // 小圆点变化
    $dt.eq(idx).addClass("active").siblings().removeClass("active")
}

// 左按钮点击事件
$leftBtn.click(function () {
    // 防流氓
    if (!$imgs.is(":animated")) {
        // 当前图片淡出
        $imgs.eq(idx).fadeOut(600)
        // 改变信号量
        idx --
        // 判断信号量边界
        if (idx < 0 ) {
            idx = length - 1
        } 
        // 下一张图片淡入
        $imgs.eq(idx).fadeIn(600)
        // 小圆点变化
        $dt.eq(idx).addClass("active").siblings().removeClass("active")
    }
})

// 移动到小圆点事件
$dt.mouseenter(function () {
    // 当前图片淡出
    $imgs.eq(idx).stop(true).fadeOut(600)
    // 改变信号
    idx = $(this).index()
    // 当前图片淡入
    $imgs.eq(idx).stop(true).fadeIn(600)
    // 改变active
    $dt.eq(idx).addClass("active").siblings().removeClass("active")
})
```

## 2. 呼吸轮播图(遮罩)

```
// 获取元素
var $imgs = $("#carousel .imgs li")
var length = $imgs.length
var $carousel = $("#carousel")
var $leftBtn = $("#carousel .btns .leftBtn")
var $rightBtn = $("#carousel .btns .rightBtn")
var $dt = $("#dt li")

// 定义信号量
var idx = 0

// 开启定时器
var timer = setInterval(change, 2000)

// 鼠标进入
$carousel.mouseenter(function () {
    // 清除定时器
    clearInterval(timer)
})

// 鼠标离开
$carousel.mouseleave(function () {
    // 再次清除定时器
    clearInterval(timer)
    // 开启定时器
    timer = setInterval(change, 2000)
})

// 右按钮点击事件
$rightBtn.click(change)

// 封装右按钮事件
function change() {
    // 防流氓
    if ($imgs.is(":animated")) {
        return
    }
    // 当前图片淡出
    $imgs.eq(idx).fadeOut(600, function () {
        // 改变信号量
        idx ++
        // 判断信号量边界
        if (idx > length - 1) {
            idx = 0
        }
        // 下一张图片进入
        $imgs.eq(idx).fadeIn(600)
        // 小圆点变化
        $dt.eq(idx).addClass("active").siblings().removeClass("active")
    })
    
}

// 左按钮点击事件
$leftBtn.click(function () {
    // 防流氓
    if (!$imgs.is(":animated")) {
        // 当前图片淡出
        $imgs.eq(idx).fadeOut(600, function () {
            // 改变信号量
            idx --
            // 判断信号量边界
            if (idx < 0 ) {
                idx = length - 1
            } 
            // 下一张图片淡入
            $imgs.eq(idx).fadeIn(600)
            // 小圆点变化
            $dt.eq(idx).addClass("active").siblings().removeClass("active")
        })
    }
})

// 移动到小圆点事件
$dt.mouseenter(function () {
    // 当前图片淡出
    $imgs.eq(idx).stop(true).fadeOut(600, function () {
        // 改变信号
        idx = $(this).index()
        // 当前图片淡入
        $imgs.eq(idx).stop(true).fadeIn(600)
        // 改变active
        $dt.eq(idx).addClass("active").siblings().removeClass("active")
    })
})
```

## 3. 安徽龙禧(呼吸)

```
// 获取元素
var $imgs = $(".banner .imgs li")
var $banner = $(".banner")
var $circles = $(".circles li")
var length = $imgs.length

console.log($circles)

// 定义信号量
idx = 0

// 开启定时器
var timer = setInterval(change, 2000)

// 模拟右按钮事件
function change() {
    // 防止动画积累
    if ($imgs.is(":animated")) {
        return
    }
    // 当前图片淡出
    $imgs.eq(idx).fadeOut(600)
    // 改变信号量
    idx ++
    // 设置信号量边界
    if (idx > length - 1) {
        idx = 0
    }
    // 下一张图片淡入
    $imgs.eq(idx).fadeIn(600)
    // 小圆点改变
    $circles.eq(idx).addClass("cur").siblings().removeClass("cur")
}

// 鼠标进入
$banner.mouseenter(function () {
    // 清除定时器
    clearTimeout(timer)
})
// 鼠标离开
$banner.mouseleave(function () {
    // 再次清除定时器
    clearTimeout(timer)
    // 开启定时器
    timer = setInterval(change, 2000)
})

// 小圆点事件
$circles.mouseenter(function () {
    // 当前图片淡出
    $imgs.eq(idx).stop(true).fadeOut(600)
    // 改变信号量
    idx = $(this).index()
    // 下一张图片淡入
    $imgs.eq(idx).stop(true).fadeIn(600)
    // 改变小圆点
    $circles.eq(idx).addClass("cur").siblings().removeClass("cur")
})
```

## 4. 滚动轮播图

鼠标点击小圆点的时候会有 dada

```
// 获取元素
var $imgs = $(".imgs")
var $circles = $(".circles li")
var length = $circles.length
var $leftBtn = $(".btns .leftBtn")
var $rightBtn = $(".btns .rightBtn")
var $carousel = $(".carousel")

// 克隆子节点的第一张图片放到子节点最后
$imgs.children("li:first").clone().appendTo($imgs)

// 开启定时器
var timer = setInterval(change, 1000)
// 鼠标进入
$carousel.mouseenter(function () {
    clearInterval(timer)
})
// 鼠标离开
$carousel.mouseleave(function () {
    clearInterval(timer)
    timer = setInterval(change, 1000)
})

// 定义信号量
idx = 0;

// 右按钮点击事件
$rightBtn.click(change)
// 封装右按钮事件
function change() {
    // 防止动画积累
    if ($imgs.is(":animated")) {
        return
    }
    // 改变信号量
    idx ++
    // 图片移动
    $imgs.animate({"left": -560 * idx}, 1000, function () {
        // 判断信号量边界
        if (idx > length - 1) {
            // 重置信号量
            idx = 0
            // 改变css
            $imgs.css("left", 0)   
        }
    })
    // 设置中转量
    var i = idx <= 4 ? idx : 0 
    // 小圆点改变
    $circles.eq(i).addClass("cur").siblings().removeClass("cur")
}

// 左按钮点击事件
$leftBtn.click(function () {
    // 防止动画积累
    if ($imgs.is(":animated")) {
        return
    }
    // 改变信号量
    idx --
    // 判断信号量边界
    if (idx < 0) {
        idx = length - 1
        // 瞬移到猫腻图上
        $imgs.css("left", -560 * length)
    }
    console.log(idx)
    // 拉动图片
    $imgs.animate({"left": -560 * idx}, 1000)
    // 小圆点移动
    $circles.eq(idx).addClass("cur").siblings().removeClass("cur")
})

// 小圆点事件
$circles.mouseenter(function () {
    // 改变信号量
    idx = $(this).index()
    // 拉动图片
    $imgs.stop(true).animate({"left": -560 * idx}, 300)
    // 改变小圆点
    $circles.eq(idx).addClass("cur").siblings().removeClass("cur")
})
```

## 5. 三位置法滚动轮播图

```
// 获取元素
var $imgs = $(".imgs li")
var $circles = $(".circles li")
var length = $circles.length
var $leftBtn = $(".btns .leftBtn")
var $rightBtn = $(".btns .rightBtn")
var $carousel = $(".carousel")

// 定义信号量
idx = 0

// 右按钮点击事件
$rightBtn.click(function () {
    // 防止动画积累
    if ($imgs.is(":animated")) {
        return
    }
    // 上一张图片移走
    $imgs.eq(idx).animate({"left": -560}, 1000)
    // 改变信号量
    idx ++
    // 判断信号量
    if (idx > length - 1) {
        idx = 0
    }
    // 移动图片
    $imgs.eq(idx).css("left", 560).animate({"left": 0}, 1000)
    // 小圆点移动
    $circles.eq(idx).addClass("cur").siblings().removeClass("cur")
})

// 右按钮点击事件
$leftBtn.click(function () {{
    // 防止动画积累
    if ($imgs.is(":animated")) {
        return
    }
    // 当前图片移走
    $imgs.eq(idx).animate({"left": -560}, 1000)
    // 改变信号量
    idx --
    // 判断信号量边界
    if (idx < 0) {
        idx = length - 1
    }
    // 下一张图片进来
    $imgs.eq(idx).css("left", 560).animate({"left": 0}, 1000)
    // 小圆点移动
    $circles.eq(idx).addClass("cur").siblings().removeClass("cur")
}})

// 小圆点事件
$circles.mouseenter(function() {
    // 获取小圆点的序号
    var i = $(this).index();

    // 判断当前小圆点的序号与信号量之间的关系
    if (i > idx) {
        // 图片应该从右侧出现，等价于右按钮点击事件
        // 当前图片到退场的位置 -560
        $imgs.eq(idx).stop(true).animate({"left": -560}, 1000);

        // 改变信号量
        idx = i;

        // 下一张图片从560的位置动画进来
        $imgs.eq(idx).css("left", 560).stop(true).animate({"left": 0}, 1000);

        // 对应信号量的小圆点要加cur
        $(this).addClass("cur").siblings().removeClass("cur");
    } else {
        // 图片应该从左侧出现， 等价于左按钮点击事件
        // 当前图片退场到560的位置
        $imgs.eq(idx).stop(true).animate({"left": 560}, 1000);

        // 改变信号量
        idx = i;

        // 下一张图片从-560的位置进来
        $imgs.eq(idx).css("left", -560).stop(true).animate({"left": 0}, 1000);

        // 对应信号量的小圆点要加cur
        $(this).addClass("cur").siblings().removeClass("cur");
    }
})
```

## 6. 上下滚动轮播图

```
// 获取元素
var $carousel = $(".carousel")
var $unit = $(".carousel #unit")
var length = $unit.children().length

// 定义信号量
var idx = 0

// 补充li
if (length % 3 === 1) {
	$("<li></li><li></li>").appendTo($unit)
} else if (length % 3 === 2) {
	$("<li></li>").appendTo($unit)
}

// 添加猫腻图
$unit.children("li:lt(3)").clone().appendTo($unit)

// 开启定时器
var timer = setInterval(change, 2000)

// 封装事件函数
function change() {
	// 改变信号量
	idx ++
	// 移动$unit
	$unit.animate({"top": -90 * idx}, 600, function () {
		// 猫腻图完全进入后再判断信号量
		if (idx > $unit.children().length / 3 - 2) {
			idx = 0
			// 瞬移到猫腻图
			$unit.css("top", 0)
		}
	})
}
```

## 7. 手风琴效果

```
// 获取元素
var $carousel = $(".carousel")

// 定义信号量
var idx = 0

// 鼠标进入效果
$("li").mouseenter(function () {
    // 防止动画积累
    $("li").stop(true)
    // 获取当前索引值
    idx = $(this).index()
    // 小于或等于当前索引值的跟85相关
    $("li:lt(" + (idx + 1) + ")").each(function (i) {
        $(this).animate({"left": 85 * i}, 600)
    })
    // 大于当前索引值的跟5560相关
    $("li:gt(" + idx + ")").each(function (i) {
        $(this).animate({"left": 560 + 85 * (i + idx)}, 600)
    })
    // 遮罩消失
    $(this).children(".mask").stop(true).fadeOut()
    // 排他
    $(this).siblings().children(".mask").stop(true).fadeIn()
})
// 鼠标离开效果
$carousel.mouseleave(function () {
    // 防止动画积累
    $("li").stop(true)
    // 所有图片都恢复遮罩
    $("li").children(".mask").stop(true).fadeIn()
    // 所有图片移动
    $("li").each(function (i) {
        $(this).animate({"left": 180 * i}, 600)
    })
})
```

## 8. 篮球积分系统

```
// 普通思维
var fenshuA = 0
var fenshuB = 0

// 加1分
$(".btn1").click(function () {
    // 判断是A队还是B队
    if ($(".duiA").is(":checked")) {
        // 改变分数
        fenshuA ++
        $(".fenA").html(fenshuA)
    } else {
        // 改变分数
        fenshuB ++
        $(".fenB").html(fenshuB)
    }
})

// 加2分
$(".btn2").click(function () {
    // 判断是A队还是B队
    if ($(".duiA").is(":checked")) {
        // 改变分数
        fenshuA += 2
        $(".fenA").html(fenshuA)
    } else {
        // 改变分数
        fenshuB += 2
        $(".fenB").html(fenshuB)
    }
})

// 加3分
$(".btn3").click(function () {
    // 判断是A队还是B队
    if ($(".duiA").is(":checked")) {
        // 改变分数
        fenshuA += 3
        $(".fenA").html(fenshuA)
    } else {
        // 改变分数
        fenshuB += 3
        $(".fenB").html(fenshuB)
    }
})
```

```
// 数组思维
var fenshu = [0, 0]
var dui = [$(".fenA"), $(".fenB")]
// 定义信号量
idx = 0
// 选队点击事件
$(".xuan").click(function () {
    // 信号量用来保存触发事件的序号
    idx = $(this).index()
})

// 加1分
$(".btn1").click(function () {
    // 让数组里面的分数改变
    fenshu[idx] += 1
    // 体现到分数上
    dui[idx].html(fenshu[idx])
})

// 加2分
$(".btn2").click(function () {
    // 让数组里面的分数改变
    fenshu[idx] += 2
    // 体现到分数上
    dui[idx].html(fenshu[idx])
})

// 加3分
$(".btn3").click(function () {
    // 让数组里面的分数改变
    fenshu[idx] += 3
    // 体现到分数上
    dui[idx].html(fenshu[idx])
})
```

```
// 遍历思维， 推荐用这个
var fenshuA = 0
var fenshuB = 0

// 给所有的button添加点击事件
$("button").each(function(i) {
	$(this).click(function() {
		// console.log("事件执行了");
		// 判断哪个队被选中了
		if ($("#duiA").is(":checked")) {
			// fenshuA++
			fenshuA += i + 1;
			// console.log(fenshuA);

			// 体现在元素身上
			$("#fenA").html(fenshuA);
		} else {
			// 说明B队被选中了
			fenshuB += i + 1;

			// 体现在元素身上
			$("#fenB").html(fenshuB);

		}
	})
})
```

## 9. 异型滚动轮播图

```
// 获取元素
var $leftBtn = $(".btns #leftBtn")
var $rightBtn = $(".btns #rightBtn")

// 定义数组
var jsonArr = []

// 循环读取li属性保存到数组中
for (var i = 0; i < 7; i ++) {
	// 读取到的属性状态保存到json中
	jsonArr.push({
		"width": $(".no" + i).css("width"),
		"height": $(".no" + i).css("height"),
		"left": $(".no" + i).css("left"),
		"top": $(".no" + i).css("top")
	})
}

// 定义数组保存类名
var classArr = ["no0", "no1", "no2", "no3", "no4", "no5", "no6"]

// 右按钮点击事件
$rightBtn.click(function () {
	// 防止动画积累
	if ($("li").is(":animated")) {
		return
	}
	// 移动图片,让 no x 移动到 no x - 1 的位置
	$(".no1").animate(jsonArr[0], 600)
	$(".no2").animate(jsonArr[1], 600)
	$(".no3").animate(jsonArr[2], 600)
	$(".no4").animate(jsonArr[3], 600)
	$(".no5").animate(jsonArr[4], 600)
	$(".no6").animate(jsonArr[5], 600)
	// 使用动画会使得no0横穿过去,使用css不会有动画效果,直接"瞬移"
	$(".no0").css(jsonArr[6])

	// 轮换类名, 删除最后一项类名到第一项
	classArr.unshift(classArr.pop())
	// 类名应用到图片上, each是jq独有的方法,js原生请使用for
	$("li").each(function (i) {
		$(this).attr("class", classArr[i])
	})
})

// 左按钮事件
$leftBtn.click(function () {
	// 防止动画积累
	if ($("li").is(":animated")) {
		return
	}
	// 移动图片, 同上
	$(".no0").animate(jsonArr[1], 600)
	$(".no1").animate(jsonArr[2], 600)
	$(".no2").animate(jsonArr[3], 600)
	$(".no3").animate(jsonArr[4], 600)
	$(".no4").animate(jsonArr[5], 600)
	$(".no5").animate(jsonArr[6], 600)
	// 特殊情况
	$(".no6").css(jsonArr[0])

	// 轮换类名
	classArr.push(classArr.shift())
	// 应用到图片上
	$("li").each(function (i) {
		$(this).attr("class", classArr[i])
	})
})
```

## 10. 碎片轮播图

```
// 所有的内容写在IIFE中防止全局变量污染
(function () {

    // 获取元素
    var $banner = $(".banner")
    var $imgs = $(".imgs li")
    var $banner = $(".banner")
    var $circles = $(".circles li")

    // 添加一个猫腻图
    var $maoni = $("<li class='maoni'></li>").appendTo($(".imgs"))

    // 点击关闭按钮
    $(".close").click(function () {
        // 遮罩消失
        $(this).parent().fadeOut(600) 
    })

    // 刷新页面遮罩出来
    $(".mask").eq(0).fadeIn(1000)

    // 定义数组用来保存所有的碎片图
    var team = (function() {
        var arr = []
        for (var i = 0; i < 3; i ++) {
            for (var j = 0; j < 6; j ++) {
                arr.push($("<div></div>").css({
                    "width": 0,
                    "height": 0,
                    "background": "url(images/slider-img1.jpg) no-repeat " + j * -138.33 + "px " + i * -143.66 + "px",
                    "position": "absolute",
                    "left": j * 138.33,
                    "top": i * 143.66
                }).appendTo($maoni))
            }
        }
        return arr
    })()


    // 定义小圆点信号量
    var small_idx = 0
    // 定义大图片信号量
    var big_idx = 0
    // 点击小圆点
    $circles.click(change)
    // 启用锁
    var lock = true
    // 封装函数
    function change() {
        // 判断锁的状态
        if (!lock) {
            return
        }
        // 上锁
        lock = false

        // 小圆点信号量改变
        small_idx = $(this).index()

        // 判断信号量
        if (small_idx === big_idx) {
            // 解锁, 什么都不做结束事件
            lock = true
            return
        }
        // 小圆点加active
        $(this).addClass("active").siblings().removeClass("active")
        // 原来图片的遮罩消失
        $(".mask").eq(big_idx).fadeOut(600)
        // 猫腻图也加上active
        $maoni.addClass("active")
        // 轮换猫腻图, 通过each遍历为每一个div执行动画
        $.each(team, function (index, value) {
            value.css("background-image", "url(images/slider-img" + (small_idx + 1) + ".jpg)").animate({
                "width": 138.33,
                "height": 143.66
            }, 300 + Math.random() * 3000)
        })
    }

    // 设置延时器
    setTimeout(function () {
        // 改变大图信号量
        big_idx = small_idx
        // 真图显示
        $imgs.eq(big_idx).addClass("active").siblings().removeClass("active")
        // 猫腻图隐藏
        $maoni.children().css({
            "width": 0,
            "height": 0
        })
        // 大图对应的遮罩需要显示
        $(".mask").eq(big_idx).fadeIn(600)
    }, 3310)
})()
```

