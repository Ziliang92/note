# ==Ajax 简介==

## 1. 定义

Ajax 即“**A***synchronous* **J***avascript **A**nd* **X***ML*”（异步 JavaScript 和 XML），是指一种创建交互式[网页](https://baike.baidu.com/item/%E7%BD%91%E9%A1%B5/99347)应用的网页开发技术。

Ajax = 异步 [JavaScript](https://baike.baidu.com/item/JavaScript) 和 XML 或者是 HTML（[标准通用标记语言](https://baike.baidu.com/item/%E6%A0%87%E5%87%86%E9%80%9A%E7%94%A8%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/6805073)的子集）。

Ajax 是一种用于创建快速动态网页的技术。

Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。

通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。

传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。

`XML` ：可以作为前后端传递数据的文件存放。也可以作为后端的配置文件。

现在已经不再使用XML作为前后端传递数据的格式了。改为使用JSON格式的数据。

## 2. 来源

Ajax 这个术语源自描述从基于 Web 的应用到基于数据的应用。

Ajax 不是一种新的编程语言，而是一种用于创建更好更快以及交互性更强的Web应用程序的技术。

使用 JavaScript 向服务器提出请求并处理响应而不阻塞用户核心对象XMLHttpRequest。通过这个对象，您的 JavaScript 可在不重载页面的情况与 Web 服务器交换数据，即在不需要刷新页面的情况下，就可以产生局部刷新的效果。

Ajax 在浏览器与 Web 服务器之间使用异步数据传输（HTTP 请求），这样就可使网页从服务器请求少量的信息，而不是整个页面。

Ajax可使因特网应用程序更小、更快，更友好。

Ajax 是一种独立于 Web 服务器软件的浏览器技术。　Ajax 基于下列 Web 标准：

JavaScript、XML、HTML与 CSS 在 Ajax 中使用的 Web 标准已被良好定义，并被所有的主流浏览器支持。Ajax 应用程序独立于浏览器和平台。

Web 应用程序较桌面应用程序有诸多优势；它们能够涉及广大的用户，它们更易安装及维护，也更易开发。
不过，因特网应用程序并不像传统的桌面应用程序那样完善且友好。通过 Ajax，因特网应用程序可以变得更完善，更友好。

![image-20190409014240907](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/2vmhv.png)

![image-20190409014306463](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/nq1q4.png)

## 3. 开发模式

许多重要的技术和 Ajax 开发模式可以从现有的知识中获取。例如，在一个发送请求到服务端的应用中，必须包含请求顺序、优先级、超时响应、错误处理及回调，其中许多元素已经在Web 服务中包含了。同时，随着技术的成熟还会有许多地方需要改进，特别是UI部分的易用性。

Ajax 开发与传统的 B/S开发有很大的不同。这些不同引入了新的编程问题，最大的问题在于易用性。由于 Ajax 依赖浏览器的 JavaScript 和XML，浏览器的兼容性和支持的标准也变得和 JavaScript 的运行时性能一样重要了。这些问题中的大部分来源于浏览器、服务器和技术的组合，因此必须理解如何才能最好的使用这些技术。

综合各种变化的技术和强耦合的客户服务端环境，Ajax 提出了一种新的开发方式。Ajax 开发人员必须理解传统的 MVC 架构，这限制了应用层次之间的边界。同时，开发人员还需要考虑 B/S 环境的外部和使用 Ajax 技术来重定型 MVC 边界。最重要的是，Ajax 开发人员必须禁止以页面集合的方式来考虑 Web 应用而需要将其认为是单个页面。一旦 UI 设计与服务架构之间的范围被严格区分开来后，开发人员就需要更新和变化的技术集合了。

## 4. 优缺点

使用Ajax的最大优点，就是能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送那些没有改变的信息。

Ajax不需要任何浏览器插件，但需要用户**允许JavaScript在浏览器上执行**。就像[DHTML](https://baike.baidu.com/item/DHTML)应用程序那样，Ajax应用程序必须在众多不同的浏览器和平台上经过严格的测试。随着Ajax的成熟，一些简化Ajax使用方法的程序库也相继问世。同样，也出现了另一种辅助程序设计的技术，为那些不支持[JavaScript](https://baike.baidu.com/item/JavaScript)的用户提供替代功能。

对应用Ajax最主要的批评就是，它可能破坏浏览器的后退与加入收藏书签功能。在动态更新页面的情况下，用户无法回到前一个页面状态，这是因为浏览器仅能记下历史记录中的[静态页面](https://baike.baidu.com/item/%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2)。一个被完整读入的页面与一个已经被动态修改过的页面之间的可能差别非常微妙；用户通常都希望单击后退按钮，就能够取消他们的前一次操作，但是在Ajax应用程序中，却无法这样做。不过开发者已想出了种种办法来解决这个问题，[HTML5](https://baike.baidu.com/item/HTML5)之前的方法大多是在用户单击后退按钮访问历史记录时，通过创建或使用一个隐藏的IFRAME来重现页面上的变更。（例如，当用户在Google Maps中单击后退时，它在一个隐藏的[IFRAME](https://baike.baidu.com/item/IFRAME)中进行搜索，然后将搜索结果反映到Ajax元素上，以便将应用程序状态恢复到当时的状态）。

关于无法将状态加入收藏或书签的问题，[HTML5](https://baike.baidu.com/item/HTML5)之前的一种方式是使用[URL](https://baike.baidu.com/item/URL)片断标识符（通常被称为[锚点](https://baike.baidu.com/item/%E9%94%9A%E7%82%B9)，即URL中#后面的部分）来保持追踪，允许用户回到指定的某个应用程序状态。（许多浏览器允许JavaScript动态更新锚点，这使得Ajax应用程序能够在更新显示内容的同时更新锚点。）[HTML5](https://baike.baidu.com/item/HTML5)以后可以直接操作浏览历史，并以字符串形式存储网页状态，将网页加入网页收藏夹或书签时状态会被隐形地保留。上述两个方法也可以同时解决无法后退的问题。

进行Ajax开发时，网络延迟——即用户发出请求到服务器发出响应之间的间隔——需要慎重考虑。如果不给予用户明确的回应，没有恰当的预读数据，或者对XMLHttpRequest的不恰当处理，都会使用户感到厌烦。通常的解决方案是，使用一个可视化的组件来告诉用户系统正在进行后台操作并且正在读取数据和内容。

## 5. 兼容性

AJAX不是一门新出现的技术，而是一套技术体系

AJAX指的是悄悄地发起HTTP请求，去服务器请求新的数据回来，更新到页面上。

由：DOM、JS、JSON、XMLHttpRequest等组成

IE5支持AJAX。不过在`IE8`及之前兼容 ActiveXObject 工厂构造函数

IE8及之后及高级浏览器 兼容 XMLHttpRequest 构造函数

> ActiveXObject 该对象是微软的私有拓展名, 只在微软的IE浏览器上支持, 在win8的应用商店下载的其他浏览器应用也不被支持.

### 能力检测

```
// 初始化 xhr
var xhr = null
if ( window.ActiveXObject ) {
	xhr = new ACtiveXObject
}
xhr = new XMLHttpRequest
```

# ==XMLHttpRequest 对象==

## 1. 简介

浏览器与服务器之间，采用 HTTP 协议通信。用户在浏览器地址栏键入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会向服务器发出 HTTP 请求。

1999年，微软公司发布 IE 浏览器5.0版，第一次引入新功能：允许 JavaScript 脚本向服务器发起 HTTP 请求。这个功能当时并没有引起注意，直到2004年 Gmail 发布和2005年 Google Map 发布，才引起广泛重视。2005年2月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。后来，AJAX 这个词就成为 JavaScript 脚本发起 HTTP 通信的代名词，也就是说，只要用脚本发起通信，就可以叫做 AJAX 通信。W3C 也在2006年发布了它的国际标准。

具体来说，AJAX 包括以下几个步骤。

1. 创建 XMLHttpRequest 实例
2. 发出 HTTP 请求
3. 接收服务器传回的数据
4. 更新网页数据

概括起来，就是一句话，AJAX 通过原生的`XMLHttpRequest`对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了，但是 AJAX 这个名字已经成了一个通用名词，字面含义已经消失了。

`XMLHttpRequest`对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。尽管名字里面有`XML`和`Http`，它实际上可以使用多种协议（比如`file`或`ftp`），发送任何格式的数据（包括字符串和二进制）。

`XMLHttpRequest`本身是一个构造函数，可以使用`new`命令生成实例。它没有任何参数。

```
var xhr = new XMLHttpRequest();
```

一旦新建实例，就可以使用`open()`方法发出 HTTP 请求。

```
xhr.open('GET', 'http://www.example.com/page.php', true);
```

上面代码向指定的服务器网址，发出 GET 请求。

然后，指定回调函数，监听通信状态（`readyState`属性）的变化。

```
xhr.onreadystatechange = handleStateChange;

function handleStateChange() {
  // ...
}
```

上面代码中，一旦`XMLHttpRequest`实例的状态发生变化，就会调用监听函数`handleStateChange`

一旦拿到服务器返回的数据，AJAX 不会刷新整个网页，而是只更新网页里面的相关部分，从而不打断用户正在做的事情。

注意，AJAX 只能向同源网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错。

下面是`XMLHttpRequest`对象简单用法的完整例子。

```
var xhr = new XMLHttpRequest();

xhr.onreadystatechange = function(){
  // 通信成功时，状态值为4
  if (xhr.readyState === 4){
    if (xhr.status === 200){
      console.log(xhr.responseText);
    } else {
      console.error(xhr.statusText);
    }
  }
};

xhr.onerror = function (e) {
  console.error(xhr.statusText);
};

xhr.open('GET', '/endpoint', true);
xhr.send(null);
```

## 2. XMLHttpRequest 的实例属性

### XMLHttpRequest.readyState

`XMLHttpRequest.readyState`返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。

- 0，表示 XMLHttpRequest 实例已经生成，但是实例的`open()`方法还没有被调用。
- 1，表示`open()`方法已经调用，但是实例的`send()`方法还没有调用，仍然可以使用实例的`setRequestHeader()`方法，设定 HTTP 请求的头信息。
- 2，表示实例的`send()`方法已经调用，并且服务器返回的头信息和状态码已经收到。
- 3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的`responseType`属性等于`text`或者空字符串，`responseText`属性就会包含已经收到的部分信息。
- 4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。

通信过程中，每当实例对象发生状态变化，它的`readyState`属性的值就会改变。这个值每一次变化，都会触发`readyStateChange`事件。

```
var xhr = new XMLHttpRequest();

if (xhr.readyState === 4) {
  // 请求结束，处理服务器返回的数据
} else {
  // 显示提示“加载中……”
}
```

上面代码中，`xhr.readyState`等于`4`时，表明脚本发出的 HTTP 请求已经完成。其他情况，都表示 HTTP 请求还在进行中。

### XMLHttpRequest.onreadystatechange

`XMLHttpRequest.onreadystatechange`属性指向一个监听函数。`readystatechange`事件发生时（实例的`readyState`属性变化），就会执行这个属性。

另外，如果使用实例的`abort()`方法，终止 XMLHttpRequest 请求，也会造成`readyState`属性变化，导致调用`XMLHttpRequest.onreadystatechange`属性。

下面是一个例子。

```
var xhr = new XMLHttpRequest();
xhr.open( 'GET', 'http://example.com' , true );
xhr.onreadystatechange = function () {
  if (xhr.readyState !== 4 || xhr.status !== 200) {
    return;
  }
  console.log(xhr.responseText);
};
xhr.send();
```

### XMLHttpRequest.response

`XMLHttpRequest.response`属性表示服务器返回的数据体（即 HTTP 回应的 body 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体的类型由`XMLHttpRequest.responseType`属性决定。该属性只读。

如果本次请求没有成功或者数据不完整，该属性等于`null`。但是，如果`responseType`属性等于`text`或空字符串，在请求没有结束之前（`readyState`等于3的阶段），`response`属性包含服务器已经返回的部分数据。

```
var xhr = new XMLHttpRequest();

xhr.onreadystatechange = function () {
  if (xhr.readyState === 4) {
    handler(xhr.response);
  }
}
```

### XMLHttpRequest.responseType

`XMLHttpRequest.responseType`属性是一个字符串，表示服务器返回数据的类型。这个属性是可写的，可以在调用`open()`方法之后、调用`send()`方法之前，设置这个属性的值，告诉服务器返回指定类型的数据。如果`responseType`设为空字符串，就等同于默认值`text`。

`XMLHttpRequest.responseType`属性可以等于以下值。

- ""（空字符串）：等同于`text`，表示服务器返回文本数据。
- "arraybuffer"：ArrayBuffer 对象，表示服务器返回二进制数组。
- "blob"：Blob 对象，表示服务器返回二进制对象。
- "document"：Document 对象，表示服务器返回一个文档对象。
- "json"：JSON 对象。
- "text"：字符串。

上面几种类型之中，`text`类型适合大多数情况，而且直接处理文本也比较方便。`document`类型适合返回 HTML / XML 文档的情况，这意味着，对于那些打开 CORS 的网站，可以直接用 Ajax 抓取网页，然后不用解析 HTML 字符串，直接对抓取回来的数据进行 DOM 操作。`blob`类型适合读取二进制数据，比如图片文件。

```
var xhr = new XMLHttpRequest();
xhr.open('GET', '/path/to/image.png', true);
xhr.responseType = 'blob';

xhr.onload = function(e) {
  if (this.status === 200) {
    var blob = new Blob([xhr.response], {type: 'image/png'});
    // 或者
    var blob = xhr.response;
  }
};

xhr.send();
```

如果将这个属性设为`ArrayBuffer`，就可以按照数组的方式处理二进制数据。

```
var xhr = new XMLHttpRequest();
xhr.open('GET', '/path/to/image.png', true);
xhr.responseType = 'arraybuffer';

xhr.onload = function(e) {
  var uInt8Array = new Uint8Array(this.response);
  for (var i = 0, len = binStr.length; i < len; ++i) {
    // var byte = uInt8Array[i];
  }
};

xhr.send();
```

如果将这个属性设为`json`，浏览器就会自动对返回数据调用`JSON.parse()`方法。也就是说，从`xhr.response`属性（注意，不是`xhr.responseText`属性）得到的不是文本，而是一个 JSON 对象。

### XMLHttpRequest.responseText

`XMLHttpRequest.responseText`属性返回从服务器接收到的字符串，该属性为只读。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据。

```
var xhr = new XMLHttpRequest();
xhr.open('GET', '/server', true);

xhr.responseType = 'text';
xhr.onload = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(xhr.responseText);
  }
};

xhr.send(null);
```

### XMLHttpRequest.responseXML

`XMLHttpRequest.responseXML`属性返回从服务器接收到的 HTML 或 XML 文档对象，该属性为只读。如果本次请求没有成功，或者收到的数据不能被解析为 XML 或 HTML，该属性等于`null`。

该属性生效的前提是 HTTP 回应的`Content-Type`头信息等于`text/xml`或`application/xml`。这要求在发送请求前，`XMLHttpRequest.responseType`属性要设为`document`。如果 HTTP 回应的`Content-Type`头信息不等于`text/xml`和`application/xml`，但是想从`responseXML`拿到数据（即把数据按照 DOM 格式解析），那么需要手动调用`XMLHttpRequest.overrideMimeType()`方法，强制进行 XML 解析。

该属性得到的数据，是直接解析后的文档 DOM 树。

```
var xhr = new XMLHttpRequest();
xhr.open('GET', '/server', true);

xhr.responseType = 'document';
xhr.overrideMimeType('text/xml');

xhr.onload = function () {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(xhr.responseXML);
  }
};

xhr.send(null);
```

### XMLHttpRequest.responseURL

`XMLHttpRequest.responseURL`属性是字符串，表示发送数据的服务器的网址。

```
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://example.com/test', true);
xhr.onload = function () {
  // 返回 http://example.com/test
  console.log(xhr.responseURL);
};
xhr.send(null);
```

注意，这个属性的值与`open()`方法指定的请求网址不一定相同。如果服务器端发生跳转，这个属性返回最后实际返回数据的网址。另外，如果原始 URL 包括锚点（fragment），该属性会把锚点剥离。

### XMLHttpRequest.status，XMLHttpRequest.statusText

`XMLHttpRequest.status`属性返回一个整数，表示服务器回应的 HTTP 状态码。一般来说，如果通信成功的话，这个状态码是200；如果服务器没有返回状态码，那么这个属性默认是200。请求发出之前，该属性为`0`。该属性只读。

- 200, OK，访问正常
- 301, Moved Permanently，永久移动
- 302, Moved temporarily，暂时移动
- 304, Not Modified，未修改
- 307, Temporary Redirect，暂时重定向
- 401, Unauthorized，未授权
- 403, Forbidden，禁止访问
- 404, Not Found，未发现指定网址
- 500, Internal Server Error，服务器发生错误

基本上，只有2xx和304的状态码，表示服务器返回是正常状态。

```
if (xhr.readyState === 4) {
  if ( (xhr.status >= 200 && xhr.status < 300)
    || (xhr.status === 304) ) {
    // 处理服务器的返回数据
  } else {
    // 出错
  }
}
```

`XMLHttpRequest.statusText`属性返回一个字符串，表示服务器发送的状态提示。不同于`status`属性，该属性包含整个状态信息，比如“OK”和“Not Found”。在请求发送之前（即调用`open()`方法之前），该属性的值是空字符串；如果服务器没有返回状态提示，该属性的值默认为“OK”。该属性为只读属性。

### XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout

`XMLHttpRequest.timeout`属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。

`XMLHttpRequestEventTarget.ontimeout`属性用于设置一个监听函数，如果发生 timeout 事件，就会执行这个监听函数。

下面是一个例子。

```
var xhr = new XMLHttpRequest();
var url = '/server';

xhr.ontimeout = function () {
  console.error('The request for ' + url + ' timed out.');
};

xhr.onload = function() {
  if (xhr.readyState === 4) {
    if (xhr.status === 200) {
      // 处理服务器返回的数据
    } else {
      console.error(xhr.statusText);
    }
  }
};

xhr.open('GET', url, true);
// 指定 10 秒钟超时
xhr.timeout = 10 * 1000;
xhr.send(null);
```

### 事件监听属性

XMLHttpRequest 对象可以对以下事件指定监听函数。

- XMLHttpRequest.onloadstart：loadstart 事件（HTTP 请求发出）的监听函数
- XMLHttpRequest.onprogress：progress事件（正在发送和加载数据）的监听函数
- XMLHttpRequest.onabort：abort 事件（请求中止，比如用户调用了`abort()`方法）的监听函数
- XMLHttpRequest.onerror：error 事件（请求失败）的监听函数
- XMLHttpRequest.onload：load 事件（请求成功完成）的监听函数
- XMLHttpRequest.ontimeout：timeout 事件（用户指定的时限超过了，请求还未完成）的监听函数
- XMLHttpRequest.onloadend：loadend 事件（请求完成，不管成功或失败）的监听函数

下面是一个例子。

```
xhr.onload = function() {
 var responseText = xhr.responseText;
 console.log(responseText);
 // process the response.
};

xhr.onabort = function () {
  console.log('The request was aborted');
};

xhr.onprogress = function (event) {
  console.log(event.loaded);
  console.log(event.total);
};

xhr.onerror = function() {
  console.log('There was an error!');
};
```

`progress`事件的监听函数有一个事件对象参数，该对象有三个属性：`loaded`属性返回已经传输的数据量，`total`属性返回总的数据量，`lengthComputable`属性返回一个布尔值，表示加载的进度是否可以计算。所有这些监听函数里面，只有`progress`事件的监听函数有参数，其他函数都没有参数。

注意，如果发生网络错误（比如服务器无法连通），`onerror`事件无法获取报错信息。也就是说，可能没有错误对象，所以这样只能显示报错的提示。

### XMLHttpRequest.withCredentials

`XMLHttpRequest.withCredentials`属性是一个布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为`false`，即向`example.com`发出跨域请求时，不会发送`example.com`设置在本机上的 Cookie（如果有的话）。

如果需要跨域 AJAX 请求发送 Cookie，需要`withCredentials`属性设为`true`。注意，同源的请求不需要设置这个属性。

```
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://example.com/', true);
xhr.withCredentials = true;
xhr.send(null);
```

为了让这个属性生效，服务器必须显式返回`Access-Control-Allow-Credentials`这个头信息。

```
Access-Control-Allow-Credentials: true
```

`withCredentials`属性打开的话，跨域请求不仅会发送 Cookie，还会设置远程主机指定的 Cookie。反之也成立，如果`withCredentials`属性没有打开，那么跨域的 AJAX 请求即使明确要求浏览器设置 Cookie，浏览器也会忽略。

注意，脚本总是遵守同源政策，无法从`document.cookie`或者 HTTP 回应的头信息之中，读取跨域的 Cookie，`withCredentials`属性不影响这一点。

### XMLHttpRequest.upload

XMLHttpRequest 不仅可以发送请求，还可以发送文件，这就是 AJAX 文件上传。发送文件以后，通过`XMLHttpRequest.upload`属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：loadstart、loadend、load、abort、error、progress、timeout。

假定网页上有一个`<progress>`元素。

```
<progress min="0" max="100" value="0">0% complete</progress>
```

文件上传时，对`upload`属性指定`progress`事件的监听函数，即可获得上传的进度。

```
function upload(blobOrFile) {
  var xhr = new XMLHttpRequest();
  xhr.open('POST', '/server', true);
  xhr.onload = function (e) {};

  var progressBar = document.querySelector('progress');
  xhr.upload.onprogress = function (e) {
    if (e.lengthComputable) {
      progressBar.value = (e.loaded / e.total) * 100;
      // 兼容不支持 <progress> 元素的老式浏览器
      progressBar.textContent = progressBar.value;
    }
  };

  xhr.send(blobOrFile);
}

upload(new Blob(['hello world'], {type: 'text/plain'}));
```

## 3. XMLHttpRequest 的实例方法

### XMLHttpRequest.open()

`XMLHttpRequest.open()`方法用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受五个参数。

```
void open(
   string method,
   string url,
   optional boolean async,
   optional string user,
   optional string password
);
```

- `method`：表示 HTTP 动词方法，比如`GET`、`POST`、`PUT`、`DELETE`、`HEAD`等。
- `url`: 表示请求发送目标 URL。
- `async`: 布尔值，表示请求是否为异步，默认为`true`。如果设为`false`，则`send()`方法只有等到收到服务器返回了结果，才会进行下一步操作。该参数可选。由于同步 AJAX 请求会造成浏览器失去响应，许多浏览器已经禁止在主线程使用，只允许 Worker 里面使用。所以，这个参数轻易不应该设为`false`。
- `user`：表示用于认证的用户名，默认为空字符串。该参数可选。
- `password`：表示用于认证的密码，默认为空字符串。该参数可选。

注意，如果对使用过`open()`方法的 AJAX 请求，再次使用这个方法，等同于调用`abort()`，即终止请求。

下面发送 POST 请求的例子。

```
var xhr = new XMLHttpRequest();
xhr.open('POST', encodeURI('someURL'));
```

### XMLHttpRequest.send()

`XMLHttpRequest.send()`方法用于实际发出 HTTP 请求。它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。

下面是 GET 请求的例子。

```
var xhr = new XMLHttpRequest();
xhr.open('GET',
  'http://www.example.com/?id=' + encodeURIComponent(id),
  true
);
xhr.send(null);
```

上面代码中，`GET`请求的参数，作为查询字符串附加在 URL 后面。

下面是发送 POST 请求的例子。

```
var xhr = new XMLHttpRequest();
var data = 'email='
  + encodeURIComponent(email)
  + '&password='
  + encodeURIComponent(password);

xhr.open('POST', 'http://www.example.com', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send(data);
```

注意，所有 XMLHttpRequest 的监听事件，都必须在`send()`方法调用之前设定。

`send`方法的参数就是发送的数据。多种格式的数据，都可以作为它的参数。

```
void send();
void send(ArrayBufferView data);
void send(Blob data);
void send(Document data);
void send(String data);
void send(FormData data);
```

如果`send()`发送 DOM 对象，在发送之前，数据会先被串行化。如果发送二进制数据，最好是发送`ArrayBufferView`或`Blob`对象，这使得通过 Ajax 上传文件成为可能。

下面是发送表单数据的例子。`FormData`对象可以用于构造表单数据。

```
var formData = new FormData();

formData.append('username', '张三');
formData.append('email', 'zhangsan@example.com');
formData.append('birthDate', 1940);

var xhr = new XMLHttpRequest();
xhr.open('POST', '/register');
xhr.send(formData);
```

上面代码中，`FormData`对象构造了表单数据，然后使用`send()`方法发送。它的效果与发送下面的表单数据是一样的。

```
<form id='registration' name='registration' action='/register'>
  <input type='text' name='username' value='张三'>
  <input type='email' name='email' value='zhangsan@example.com'>
  <input type='number' name='birthDate' value='1940'>
  <input type='submit' onclick='return sendForm(this.form);'>
</form>
```

下面的例子是使用`FormData`对象加工表单数据，然后再发送。

```
function sendForm(form) {
  var formData = new FormData(form);
  formData.append('csrf', 'e69a18d7db1286040586e6da1950128c');

  var xhr = new XMLHttpRequest();
  xhr.open('POST', form.action, true);
  xhr.onload = function() {
    // ...
  };
  xhr.send(formData);

  return false;
}

var form = document.querySelector('#registration');
sendForm(form);
```

### XMLHttpRequest.setRequestHeader()

`XMLHttpRequest.setRequestHeader()`方法用于设置浏览器发送的 HTTP 请求的头信息。该方法必须在`open()`之后、`send()`之前调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。

该方法接受两个参数。第一个参数是字符串，表示头信息的字段名，第二个参数是字段值。

```
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.setRequestHeader('Content-Length', JSON.stringify(data).length);
xhr.send(JSON.stringify(data));
```

上面代码首先设置头信息`Content-Type`，表示发送 JSON 格式的数据；然后设置`Content-Length`，表示数据长度；最后发送 JSON 数据。

### XMLHttpRequest.overrideMimeType()

`XMLHttpRequest.overrideMimeType()`方法用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理。举例来说，服务器返回的数据类型是`text/xml`，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成`text/plain`，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。

```
xhr.overrideMimeType('text/plain')
```

注意，该方法必须在`send()`方法之前调用。

修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用`responseType`属性告诉服务器，就像下面的例子。只有在服务器无法返回某种数据类型时，才使用`overrideMimeType()`方法。

```
var xhr = new XMLHttpRequest();
xhr.onload = function(e) {
  var arraybuffer = xhr.response;
  // ...
}
xhr.open('GET', url);
xhr.responseType = 'arraybuffer';
xhr.send();
```

### XMLHttpRequest.getResponseHeader()

`XMLHttpRequest.getResponseHeader()`方法返回 HTTP 头信息指定字段的值，如果还没有收到服务器回应或者指定字段不存在，返回`null`。该方法的参数不区分大小写。

```
function getHeaderTime() {
  console.log(this.getResponseHeader("Last-Modified"));
}

var xhr = new XMLHttpRequest();
xhr.open('HEAD', 'yourpage.html');
xhr.onload = getHeaderTime;
xhr.send();
```

如果有多个字段同名，它们的值会被连接为一个字符串，每个字段之间使用“逗号+空格”分隔。

### XMLHttpRequest.getAllResponseHeaders()

`XMLHttpRequest.getAllResponseHeaders()`方法返回一个字符串，表示服务器发来的所有 HTTP 头信息。格式为字符串，每个头信息之间使用`CRLF`分隔（回车+换行），如果没有收到服务器回应，该属性为`null`。如果发生网络错误，该属性为空字符串。

```
var xhr = new XMLHttpRequest();
xhr.open('GET', 'foo.txt', true);
xhr.send();

xhr.onreadystatechange = function () {
  if (this.readyState === 4) {
    var headers = xhr.getAllResponseHeaders();
  }
}
```

上面代码用于获取服务器返回的所有头信息。它可能是下面这样的字符串。

```
date: Fri, 08 Dec 2017 21:04:30 GMT\r\n
content-encoding: gzip\r\n
x-content-type-options: nosniff\r\n
server: meinheld/0.6.1\r\n
x-frame-options: DENY\r\n
content-type: text/html; charset=utf-8\r\n
connection: keep-alive\r\n
strict-transport-security: max-age=63072000\r\n
vary: Cookie, Accept-Encoding\r\n
content-length: 6502\r\n
x-xss-protection: 1; mode=block\r\n
```

然后，对这个字符串进行处理。

```
var arr = headers.trim().split(/[\r\n]+/);
var headerMap = {};

arr.forEach(function (line) {
  var parts = line.split(': ');
  var header = parts.shift();
  var value = parts.join(': ');
  headerMap[header] = value;
});

headerMap['content-length'] // "6502"
```

### XMLHttpRequest.abort()

`XMLHttpRequest.abort()`方法用来终止已经发出的 HTTP 请求。调用这个方法以后，`readyState`属性变为`4`，`status`属性变为`0`。

```
var xhr = new XMLHttpRequest();
xhr.open('GET', 'http://www.example.com/page.php', true);
setTimeout(function () {
  if (xhr) {
    xhr.abort();
    xhr = null;
  }
}, 5000);
```

上面代码在发出5秒之后，终止一个 AJAX 请求。

## 4. XMLHttpRequest 实例的事件

### readyStateChange 事件

`readyState`属性的值发生改变，就会触发 readyStateChange 事件。

我们可以通过`onReadyStateChange`属性，指定这个事件的监听函数，对不同状态进行不同处理。尤其是当状态变为`4`的时候，表示通信成功，这时回调函数就可以处理服务器传送回来的数据。

### progress 事件

上传文件时，XMLHttpRequest 实例对象本身和实例的`upload`属性，都有一个`progress`事件，会不断返回上传的进度。

```
var xhr = new XMLHttpRequest();

function updateProgress (oEvent) {
  if (oEvent.lengthComputable) {
    var percentComplete = oEvent.loaded / oEvent.total;
  } else {
    console.log('无法计算进展');
  }
}

xhr.addEventListener('progress', updateProgress);

xhr.open();
```

### load 事件、error 事件、abort 事件

load 事件表示服务器传来的数据接收完毕，error 事件表示请求出错，abort 事件表示请求被中断（比如用户取消请求）。

```
var xhr = new XMLHttpRequest();

xhr.addEventListener('load', transferComplete);
xhr.addEventListener('error', transferFailed);
xhr.addEventListener('abort', transferCanceled);

xhr.open();

function transferComplete() {
  console.log('数据接收完毕');
}

function transferFailed() {
  console.log('数据接收出错');
}

function transferCanceled() {
  console.log('用户取消接收');
}
```

### loadend 事件

`abort`、`load`和`error`这三个事件，会伴随一个`loadend`事件，表示请求结束，但不知道其是否成功。

```
xhr.addEventListener('loadend', loadEnd);

function loadEnd(e) {
  console.log('请求结束，状态未知');
}
```

### timeout 事件

服务器超过指定时间还没有返回结果，就会触发 timeout 事件，具体的例子参见`timeout`属性一节。

## 5. Navigator.sendBeacon()

用户卸载网页的时候，有时需要向服务器发一些数据。很自然的做法是在`unload`事件或`beforeunload`事件的监听函数里面，使用`XMLHttpRequest`对象发送数据。但是，这样做不是很可靠，因为`XMLHttpRequest`对象是异步发送，很可能在它即将发送的时候，页面已经卸载了，从而导致发送取消或者发送失败。

解决方法就是 AJAX 通信改成同步发送，即只有发送完成，页面才能卸载。但是，很多浏览器已经不支持同步的 XMLHttpRequest 对象了（即`open()`方法的第三个参数为`false`）。

```
window.addEventListener('unload', logData, false);

function logData() {
  var client = new XMLHttpRequest();
  // 第三个参数表示同步发送
  client.open('POST', '/log', false);
  client.setRequestHeader('Content-Type', 'text/plain;charset=UTF-8');
  client.send(analyticsData);
}
```

上面代码指定`XMLHttpRequest`同步发送，很多浏览器都已经不支持这种写法。

同步通信有几种变通的方法。一种做法是新建一个`<img>`元素，数据放在`src`属性，作为 URL 的查询字符串，这时浏览器会等待图片加载完成（服务器回应），再进行卸载。另一种做法是创建一个循环，规定执行时间为几秒钟，在这几秒钟内把数据发出去，然后再卸载页面。

这些做法的共同问题是，卸载的时间被硬生生拖长了，后面页面的加载被推迟了，用户体验不好。

为了解决这个问题，浏览器引入了`Navigator.sendBeacon()`方法。这个方法还是异步发出请求，但是请求与当前页面脱钩，作为浏览器的任务，因此可以保证会把数据发出去，不拖延卸载流程。

```
window.addEventListener('unload', logData, false);

function logData() {
  navigator.sendBeacon('/log', analyticsData);
}
```

`Navigator.sendBeacon`方法接受两个参数，第一个参数是目标服务器的 URL，第二个参数是所要发送的数据（可选），可以是任意类型（字符串、表单对象、二进制对象等等）。

```
navigator.sendBeacon(url, data)
```

这个方法的返回值是一个布尔值，成功发送数据为`true`，否则为`false`。

该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据。它不能指定回调函数。

下面是一个例子。

```
// HTML 代码如下
// <body onload="analytics('start')" onunload="analytics('end')">

function analytics(state) {
  if (!navigator.sendBeacon) return;

  var URL = 'http://example.com/analytics';
  var data = 'state=' + state + '&location=' + window.location;
  navigator.sendBeacon(URL, data);
}
```

# ==发送 Ajax==

## 1. 数据格式互转

### JSON 格式的字符串 → 转 JSON

- `JSON.parse( data )`
- `data = eval( "(" + data + ")" )`
- `ata = new Function( "return" + data )()`

### JSON → 转 JSON 格式的字符串

- `JSON.stringify( { error: 0, data: "注册成功" } )`

## 2. 原生 js 方式

###  get 请求

```
// 原生发送 Ajax
// 1. 获取 xhr 对象
var xhr = null
// 能力检测
if ( window.ActiveXObject ) {
	xhr = new ActiveXObject()
} else if ( window.XMLHttpRequest ) {
	xhr = new XMLHttpRequest()
} else {
	throw new Error( "您的浏览器不支持 Ajax,请升级浏览器版本或者更换高级浏览器" )
}
// 2. 注册事件,监听函数,处理数据
xhr.onreadystatechange = function () {
	// readyState 状态为 4 时才执行
	if ( xhr.readyState === 4 ) {
		// 判断 HTTP 状态
		if ( ( xhr.status > 200 && xhr.status < 300 ) || xhr.status === 304 ) {
			// 获得服务器返回的数据
			var data = xhr.responseText
			// 将 data 由 JSON 字符串转为 JSON 对象
			// 第一种方式
			data = JSON.parse( data )
			// 第二种方式
			data = eval( "(" + data + ")" )
			// 第三种方式
			data = new Function( "return" + data )()
			// 使用拿到的数据,提示用户
			if ( data.error != 0 ) {
				// 说明请求目的没有达到
				username_lock = false
			}
			// 请求的目的达到
			username_lock = true
		}
		// 3. 调用 open 方法, 初始化 HTTP 请求的参数
		xhr.open( "get", "/checkName?username=" + val, true )
		// 4. 实际发动 http 请求
		xhr.send()
	}
	return
}
```

### post 请求

```
// 发送 Ajax
var xhr = null
if ( window.ActiveXObject ) {
	xhr = new ActiveXObject()
} else if ( window.XMLHttpRequest ) {
	xhr = new XMLHttpRequest()
} else {
	throw new Error( "您的浏览器不支持 Ajax,请升级浏览器版本或者更换高级浏览器" )
}
// 注册监听函数
xhr.onreadystatechange = function () {
	// readyState 状态不为 4 时, 直接返回
	if ( xhr.readyState !== 4 || xhr.status !== 200 ) {
		return
	}
	// 获得服务器返回的数据
	var data = xhr.responseText
	// 数据转为对象
	data = JSON.parse( data )
	$tips.modal()
	$tipsHtml.html( data.data )
}
// 初始化 http 请求参数
xhr.open( "post", "/regist", true )
// 设置请求数据的 MimeType
xhr.setRequestHeader( "content-type", "application/x-www-form-urlencoded" )
// 定义 query 参数
var query = "username=" + $username.val() + "&password=" + $password.val()
// 发送请求正文
xhr.send( query )
return
```

### 原生封装的 Ajax

```
var ickt = {
    get: function ( url, data, callback ) {
        // 当 data 是对象时, 转为字符串
        var query = ""
        if ( typeof data === "object" ) {
            for ( var i in data ) {
                query += i + "=" + data[ i ] + "&"
            }
            // 去掉最后末尾的 "&"
            query = query.slice( 0, -1 )
        } else {
            query = data
        }
        // 初始化 xhr
        var xhr = null
        if ( window.ActiveXObject ) {
            xhr = new ActiveXObject()
        } else if ( window.XMLHttpRequest ) {
            xhr = new XMLHttpRequest()
        } else {
            throw new error( "请升级浏览器" )
        }
        // 注册监听函数
        xhr.onreadystatechange = function () {
            // 判断 xhr 对象的状态 和 http 状态码
            if ( xhr.readyState !== 4 && ( xhr.status !== 200 || xhr.status !== 304 ) ) {
                return
            }
            // 获取返回的数据并转为对象
            var data = JSON.parse( xhr.responseText )
            // 执行回调函数, 传递的参数为返回的数据
            callback( data )
        }
        // 指定请求的参数
        xhr.open( "get", url + "?" + query, true )
        // 发送 end
        xhr.send()
    },
    post: function ( url, data, callback ) {
        // 当 data 是对象时, 转为字符串
        var query = ""
        if ( typeof data === "object" ) {
            for ( var i in data ) {
                query += i + "=" + data[ i ] + "&"
            }
            // 去掉最后末尾的 "&"
            query = query.slice( 0, -1 )
        } else {
            query = data
        }
        // 初始化 xhr
        var xhr = null
        if ( window.ActiveXObject ) {
            xhr = new ActiveXObject()
        } else if ( window.XMLHttpRequest ) {
            xhr = new XMLHttpRequest()
        } else {
            throw new error( "请升级浏览器" )
        }
        // 注册监听函数
        xhr.onreadystatechange = function () {
            // 判断 xhr 对象的状态 和 http 状态码
            if ( xhr.readyState !== 4 && ( xhr.status !== 200 || xhr.status !== 304 ) ) {
                return
            }
            // 获取返回的数据并转为对象
            var data = JSON.parse( xhr.responseText )
            // 执行回调函数, 传递的参数为返回的数据
            callback( data )
        }
        // 指定请求的参数
        xhr.open( "post", url, true )
        // 设置请求头中的 MimeType 信息,以指定数据类型
        xhr.setRequestHeader( "content-type", "application/x-www-form-urlencoded;charset=utf-8" )
        // 发送 end,携带数据
        xhr.send( query )
    }
}
```

## 3. jQuery 方式

### get 请求

`$.get( url, data, callback, dataType )`

该方法用于发送 get 请求。

- `url`       URL地址

- `data `     本次请求携带的数据 可以是对象也可以是字符串 可省略

- `callback`   回调函数  函数中有一个参数 是请求回来的数据

- `dataType`   请求回来的数据的类型

```
$.get( "/checkName", { username: value }, function ( data ) {
	// 提示用户
	if (data.error != 0) {
		// 说明请求目的没达到
		username_lock = false;
	} else {
		// 说明请求目的达到
		username_lock = true;
	}
	$tips.modal();
	$tipsHtml.html(data.data);
}, "JSON" )
```

### post 请求

`$.post( url, data, callback, dataType )`

该方法用于发送 post 请求。

- `url`       URL地址

- `data `     本次请求携带的数据 可以是对象也可以是字符串 可省略

- `callback`   回调函数  函数中有一个参数 是请求回来的数据

- `dataType`   请求回来的数据的类型

```
// 发送 Ajax
$.post( "/regist", { username: $username.val(), password: $password.val() }, function ( data ) {
	$tips.modal()
	$tipsHtml.html( data.data )
}, "JSON" )
```

### jQuery 封装的 Ajax

`$.ajax`

该方法用于发送所有的请求。包括GET、POST。上面的两个方法内部也是在调用 `$.ajax`

该方法接收一个参数，是一个配置对象。以下是该对象的常用属性:

- `url`： 接口地址
- `type`：GET、POST请求类型
- `data`： 请求携带的数据，JSON 对象，`jquery` 会将其转为`JSON`字符串
- `dataType`： 返回的数据类型，值为`json`时，会自动将字符串转为 `JSON 对象`
- `success`： 成功之后的回调函数， 函数参数 data 为返回的数据
- `complete`： 完成之后的回调函数，函数参数 data 为返回的数据
- `error`： 失败之后的回调函数
- `async`： true / false

![image-20190411143654457](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/hcdnl.png)

## 4. 表单序列化

`表单序列化`：指的是将表单中用户填写的数据，根据控件的`name`和`value`序列化成`k=v&k1=v1的query`字符串。

> 使用 `form`表单进行提交数据的时候，会默认进行`原生 js 中的表单序列化`

### 分析

如果使用表单提交，会刷新页面。如果成功，一切好说。但是一旦失败，则需要后退，并重新填写数据。

后来有了AJAX之后，就可以使用AJAX提交，成功，就前端跳转页面。失败，也可以直接修改，无需后退，无需重新填写数据。

当然，有利就有弊：

`表单提交`，我们并不需要关心数据。只需要给对应的控件name属性即可。

`AJAX提交`，浏览器不会将表单中的数据格式化成query字符串。所以我们只好自己写。

- 方式一：挨个获取每一个控件元素 拼接成query字符串
  - 缺点：	一旦HTML结构发生变化。代码需要修改。如果有多个表单，每一个表单都需要拼接一次。不方便复用。耦合性很强。
  - 没有优点

- 方式二：表单序列化
  - 优点：解耦
  - 没有缺点

`表单序列化的思想`：针对表单，获取表单中的所有控件，再根据所有具备name的控件进行字符串拼接。

### jQuery 中的表单序列化

`$(form).serialize()`

该方法用于将指定的表单序列化。一旦将表单结构改变，JS中的代码是不需要发生变化的。

- 返回值：表单的序列化之后的数据

```
// 获取按钮
var $registBtn = $("#registBtn");
// 点击时 进行表单的序列化
$registBtn.click(function() {
	// 获取表单元素
	var $form = $("form");
	// 序列化
	var data = $form.serialize();
	console.log(data);
});
```

![image-20190411154724299](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/6mmtg.png)

### 原生 js 中的表单序列化

```
// 原生的表单序列化
// 获取表单元素
var form = document.querySelector( "#header form" )
// 获取按钮
var Btn = document.querySelector( "button" )
// 封装表单序列化函数
function serialize( form ) {
	// 循环将控件放入数组之中
	var arr = []
	for ( var i = 0; i < form.elements.length; i ++ ) {
		if ( form.elements[ i ].name ) {
			arr.push( form.elements[ i ] )
		}
	}
	// 判断每一个控件相关属性
	var query = ""
	for ( var i = 0; i < arr.length; i ++ ) {
		// 判断
		if ( arr[ i ].type === "radio" || arr[ i ].type === "checkbox" ) {
			if ( arr[ i ].checked ) {
				query += arr[ i ].name + "=" + arr[ i ].value + "&" 
			}
		} else {
			query += arr[ i ].name + "=" + arr[ i ].value + "&" 
		}
	}
	// 删除最后一位
	query = query.slice( 0, -1 )
	return query
}

// 设置点击事件
Btn.onclick = function () {
	var data = serialize( form )
	console.log( data )
}
```

## 5. 用户注册

详细请看《 web - 爱创 - 2019年4月5日AJAX第三天 - 原生封装 Ajax 》

# ==MimeType==

## 1. 概念

**（1）简介**

首先，我们要了解浏览器是如何处理内容的。在浏览器中显示的内容有 HTML、有 XML、有 GIF、还有 Flash ……那么，浏览器是如何区分它们，决定什么内容用什么形式来显示呢？答案是 MIME Type，也就是该资源的媒体类型。

媒体类型通常是通过 HTTP 协议，由 Web 服务器告知浏览器的，更准确地说，是通过 Content-Type 来表示的，例如:

```
Content-Type: text/HTML
```

表示内容是 text/HTML 类型，也就是超文本文件。为什么是“text/HTML”而不是“HTML/text”或者别的什么？MIME Type 不是个人指定的，是经过 ietf 组织协商，以 RFC 的形式作为建议的标准发布在网上的，大多数的 Web 服务器和用户代理都会支持这个规范 (顺便说一句，Email 附件的类型也是通过 MIME Type 指定的)。

通常只有一些在互联网上获得广泛应用的格式才会获得一个 MIME Type，如果是某个客户端自己定义的格式，一般只能以 application/x- 开头。

XHTML 正是一个获得广泛应用的格式，因此，在 RFC 3236 中，说明了 XHTML 格式文件的 MIME Type 应该是 application/xHTML+XML。

当然，处理本地的文件，在没有人告诉浏览器某个文件的 MIME Type 的情况下，浏览器也会做一些默认的处理，这可能和你在操作系统中给文件配置的 MIME Type 有关。比如在 Windows 下，打开注册表的“HKEY_LOCAL_MACHINESOFTWAREClassesMIMEDatabaseContent Type”主键，你可以看到所有 MIME Type 的配置信息。

在把输出结果传送到浏览器上的时候，浏览器必须启动适当的应用程序来处理这个输出文档。这可以通过多种类型MIME（多功能网际邮件扩充协议）来完成。在HTTP中，MIME类型被定义在Content-Type header中。

例如，架设你要传送一个Microsoft Excel文件到客户端。那么这时的MIME类型就是“application/vnd.ms-excel”。在大多数实际情况中，这个文件然后将传送给Execl来处理（假设我们设定Execl为处理特殊MIME类型的应用程序）。在ASP中，设定MIME类型的方法是通过Response对象的ContentType属性。

**（2）多媒体文件格式MIME** 

最早的HTTP协议中，并没有附加的数据类型信息，所有传送的数据都被客户程序解释为超文本标记语言HTML 文档，而为了支持多媒体数据类型，HTTP协议中就使用了附加在文档之前的MIME数据类型信息来标识数据类型。

MIME意为多目Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。

Internet中有一个专门组织IANA来确认标准的MIME类型，但Internet发展的太快，很多应用程序等不及IANA来确认他们使用的MIME类型为标准类型。因此他们使用在类别中以x-开头的方法标识这个类别还没有成为标准，例如：x-gzip，x-tar等。事实上这些类型运用的很广泛，已经成为了事实标准。只要客户机和服务器共同承认这个MIME类型，即使它是不标准的类型也没有关系，客户程序就能根据MIME类型，采用具体的处理手段来处理数据。而Web服务器和浏览器（包括操作系统）中，缺省都设置了标准的和常见的MIME类型，只有对于不常见的 MIME类型，才需要同时设置服务器和客户浏览器，以进行识别。

由于MIME类型与文档的后缀相关，因此服务器使用文档的后缀来区分不同文件的MIME类型，服务器中必须定义文档后缀和MIME类型之间的对应关系。而客户程序从服务器上接收数据的时候，它只是从服务器接受数据流，并不了解文档的名字，因此服务器必须使用附加信息来告诉客户程序数据的MIME类型。服务器在发送真正的数据之前，就要先发送标志数据的MIME类型的信息，这个信息使用Content-type关键字进行定义，例如对于HTML文档，服务器将首先发送以下两行MIME标识信息,这个标识并不是真正的数据文件的一部分。

## 2. 常见类型

- 超文本标记语言文本 `.html` `.htm` .text/html 
- 普通文本 `.txt` text/plain 
- RTF文本 `.rtf` application/rtf 
- GIF图形 `.gif` image/gif 
- JPEG图形 `.ipeg` `.jpg` image/jpeg 
- au声音文件 `.au` audio/basic 
- MIDI音乐文件 `mid`,`.midi` audio/midi,audio/x-midi 
- RealAudio音乐文件 `.ra`, `.ram` audio/x-pn-realaudio 
- MPEG文件 `.mpg`,`.mpeg` video/mpeg 
- AVI文件 `.avi` video/x-msvideo 
- GZIP文件 `.gz` application/x-gzip 
- TAR文件 `.tar` application/x-tar 
- 模拟表单   application/x-www-form-urlencoded
- JSON类型   application/json
- 二进制文件    multipart/form-data

## 3. MimeType 策略对象

```
var MimeType = {
	"txt": "text/plain",
	"css": "text/css",
	"html": "text/html",
	"js": "text/javascript",
	"jpg": "image/jpeg",
	"png": "image/png",
	"gif": "image/gif"
}
```

`需要注意`的是，MimeType 存在于隐式响应头中， 不在各种请求 / 响应类型中

# ==前段渲染==

## 1. replace 方法正则使用

`str.replace(arg1, arg2)`

该方法用于将str中的一部分替换为另一部分

- `arg1`： 被替换的内容，可以是`字符串`和`正则表达式`
- `arg2`：替换上的内容，可以是`字符串` 也可以是`函数`，在模板引擎中，主要使用第二个参数为函数的方式与第一个参数为正则表达式的方式配合使用。也可以称为 `引擎函数`
  - `math`：表示多次匹配到的内容，每匹配到一次会触发一次函数的执行
  - `$1 - 99` :  第一个参数正则表达式中的圆括号所捕获的内容（`圆括号外不包括`），每一个`$`都表示下一个圆括号的内容，直到第 99 个。
  - 函数返回值： 就是替换上的内容

```
// 定义一个字符串
var str = "<div><%username%></div><p><%bank.beijing.account%></p>";
// 定义一个对象
var obj = {
	username: "王老五",
	bank: {
		beijing: {
			account: 82341236123516,
			money: 82341236
		}
	}
}
// 正则表达式在replace中的使用
str.replace(/<%([a-zA-Z_0-9]+(\.[a-zA-Z_0-9]+)*)%>/g, function(match, $1, $2) {
	console.log($1);  
});

// 输出： username
		 bank.beijing.account
```

上面代码分析： 

拿着正则表达式到`str`字符串中进行匹配

第一次匹配到` <%username%>` 函数第一次执行

所以此时的`$1`就是`username`

第二次匹配到 `<%bank.beijing.account%> `函数第二次执行

所以此时的`$1`就是`bank.beijing.account`

### 完整案例

```
// 定义一个字符串
var str = "<div><%username%></div><p><%bank.beijing.account%></p>";
// 定义一个对象
var obj = {
	username: "王老五",
	bank: {
		beijing: {
			account: 82341236123516,
			money: 82341236
		}
	}
}
// 正则表达式在replace中的使用
var str1 = str.replace(/<%([a-zA-Z_0-9]+(\.[a-zA-Z_0-9]+)*)%>/g, function(match, $1, $2) {
	// console.log($1);
	// 第一步 将$1 也就是层级路径以.分隔
	var arr = $1.split(".");
	// console.log(arr);
	// 备份obj
	var result = obj;
	// 开始循环
	for (var i = 0; i < arr.length - 1; i++) {
		// 让result不停的指向下一层级
		result = result[arr[i]];
	}
	// result 此时已经是倒数第二层
	// 返回该result的最后一层属性
	return result[arr[i]];
});
console.log(str1); // <div>123</div><p>123</p>
```

## 2. 前端渲染

前端渲染就是指浏览器会从后端得到一些信息，这些信息是适用于`angularjs`的模板文件，亦或是`JSON`等各种数据交换格式所包装的数据，甚至是直接的合法的`HTML字符串`。这些形式都不重要，重要的是，将这些信息组织排列形成`最终可读的HTML字符串`是由浏览器来完成的，`在形成了HTML字符串之后，再进行显示`。下面介绍`模板引擎`这种方式:

### 建立模板

1. 在 `HTML` 中定义好结构，书写好样式
2. 将 `HTML` 放入一个无法执行的 `js` 标签中:   将 `script` 标签的 `type` 属性改为不可执行的   `"text/template"`

3. 将模板中将来会被替换掉的部分使用特殊标签分隔开 `<%需要替换的内容%>`，任何形式都可以方便替换就行

```
<!-- 将HTML放入一个不可执行的JS标签中 -->
<script type="text/template" id="template">
	<li class="item">
		<div class="username">
			<span>用户名</span><span class="val"><%username%></span>
		</div>
		<div class="psd">
			<span>密码</span><span class="val"><%password%></span>
		</div>
	</li>
</script>
```

### 获取字典对象

从后端返回的数据，以对象的形式存在，用于替换模板中需要替换的内容

```
// 从后端返回的数据，此案例暂时定义一个对象代替
var obj = {
	username: "王老五",
	bank: {
		beijing: {
			account: 82341236123516,
			money: 82341236
		}
	}
}
```

### 引擎函数

将` replace` 方法的正则使用封装起来，称为 `引擎函数`

```
/* 字符串替换方法
 * @tpl 模板字符串 符合<%xxx.xxx.xxx%>格式
 * @dic 字典对象 必须有tpl中xxx.xxx.xxx层级
 * @return 返回值 格式化完毕之后的字符串
 */
function format(tpl, dic) {
	// 调用replace方法
	return tpl.replace(/<%([a-zA-Z_0-9]+(\.[a-zA-Z_0-9]+)*)%>/g, function(match, $1) {
		var arr = $1.split(".");
		var result = dic;
		for (var i = 0; i < arr.length - 1; i++) {
			result = result[arr[i]];
		}
		return result[arr[i]];
	});
}
```

### 渲染步骤

1. 发送AJAX 并得到返回的数据
2. `建立模板`
   1. 先在HTML中将模板定义出来并调整好样式
   2. 把模板移动到一个不可执行的script标签中
   3. 挖空可变的区域并以特殊标签将可变部分与不可变部分区分 并将层级路径写好
3. `格式化模板`
   1. 在JS中，获取模板字符串. 使用 innerHTML 方法（ text 、 textContent 方法也可以 ）
   2. 格式化，也就是执行引擎函数
4. `前端渲染`
   1. 上树， append 
   2. 渲染

## 3. 后端渲染

后端渲染HTML的情况下，浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTML字符串，这里的计算就是服务经过解析存放在服务器端的模板文件来完成的，在这种情况下，浏览器只进行了HTML的解析，以及通过操作系统提供的操纵显示器显示内容的系统调用在显示器上把HTML所代表的图像显示给用户。详细请看《nodeJS - 后端渲染》

> 三大流行框架都是用前段渲染的

# ==瀑布流布局==

## 1. 概念

这是一种网页模型。

指的是：随着用户往下拖动页面，会不断的有更多的数据填充进来，造成“永远也到不了底”的这种感觉。

## 2. 布局方式

### 顺序上树

`缺点`：上树之后，某一列的高度会远大于另外的列。

`原因`： 图片自身的宽度和高度不一致。导致随机性的某一列的高度会远大于另外的列

```
// 获取3个li
var lis = document.getElementsByTagName("li");
// 加载100张图片 用来充当100个瀑布流的模块
for (var i = 0; i < 100; i++) {
	// 创建img元素
	var img = new Image();
	// 设置src路径
	img.src = "./imgs/" + i + ".png";
	// 按照顺序添加到li中
	lis[i % 3].appendChild(img); 
}
```

### 按照高度上树

思路： 既然不可以按照顺序上树，因为高度不可控。所以我们就按照高度上树

定义一个高度映射数组。初始化的长度为li的个数。初始化的值为0。

每当有一张图片回来，就查看数组中哪个成员最小，意味着对应的li的高度最矮。这个图片就上该li中。

数组也要随之变化。

```
// 获取3个li
var lis = document.getElementsByTagName("li");
// 定义了一个高度映射数组 映射的是每个li的高度 初始情况下为0
var height_arr = new Array(lis.length).fill(0);
// 加载100张图片 用来充当100个瀑布流的模块
for (var i = 0; i < 100; i++) {
	// 创建img元素
	var img = new Image();
	// 设置src路径
	img.src = "./imgs/" + i + ".png";
	// 想要获取高度 必须获取图片本身 只能够在onload中获取
	img.onload = function() {
		// 图片已经回来了 能够获取到图片的高度了
		// 我们需要知道的是哪个列最短
		var minIdx = getMinIdx(height_arr);
		// lis[minIdx] 就是对应的最矮的列
		lis[minIdx].appendChild(this);
		// 既然是映射数组 必须得随着对应li的高度变化而变化
		height_arr[minIdx] += this.height;
	}
}

// 定义一个函数 该函数可以获取数组中最小的值的下标
function getMinIdx(arr) {
	// 返回最小的值的下标
	// 默认最小的值下标
	var idx = 0;
	// 默认最小的值
	var val = arr[idx];
	// 循环比较其他项
	for (var i = 1; i < arr.length; i++) {
		// 如果最小的值val 还比当前的项大 说明不是最小 
		if (val > arr[i]) {
			val = arr[i];
			idx = i;
		}
	}
	return idx;
}
```

## 3. 数据上树方式

### 创建元素并互相组合

`缺点`：代码多、结构一旦发生变化不容易维护，不能用

```
// 创建元素
var li = document.createElement("li");
// 第一种 创建元素 并互相组合
// 创建六个元素
var div1 = document.createElement("div");
var div1_span1 = document.createElement("span");
div1_span1.innerHTML = "用户名";
var div1_span2 = document.createElement("span");
div1_span2.innerHTML = data.data[i].username;
var div2 = document.createElement("div");
var div2_span1 = document.createElement("span");
div2_span1.innerHTML = "密码";
var div2_span2 = document.createElement("span");
div2_span2.innerHTML = data.data[i].password;
div1.appendChild(div1_span1);
div1.appendChild(div1_span2);
div2.appendChild(div2_span1);
div2.appendChild(div2_span2);
li.appendChild(div1);
li.appendChild(div2);
list.appendChild(li);
```

### 只创建最外层元素

所有的内部元素都可以视为：最外层元素的 `innerHTML`属性

这种方式极大地简化了代码 

但是因为是单行字符串，所以无法换行，导致结构不清晰，维护困难。如果强行换行需要斩断连接并再次拼接，结构清晰，但是 `+`号很难看。

```
// 第二种 只创建最外层元素 所有内部元素都是innerHTML
li.innerHTML = "<div><span>用户名</span><span>" + data.data[i].username + "</span></div><div><span>密码</span><span>" + data.data[i].password + "</span></div>";
li.innerHTML = 
"<div>" +
	"<span>用户名</span>" +
	"<span>" + data.data[i].username + "</span>" +
"</div>" +
"<div>" +
	"<span>密码</span>" + 
	"<span>" + data.data[i].password + "</span>"+ 
"</div>";
list.appendChild(li)
```

### 使用前端渲染

最佳的方式就是使用前端渲染来进行数据上树

## 4. 花瓣网瀑布流案例

具体请看 《 2019年4月5日AJAX第三天 》的视频，下面为一些需要注意的地方

- 因为自适配的关系，瀑布流都是绝对定位实现的
- svg 返回响应数据的时候， MimType 需要设置
- 使用模板引擎，四步走

- html() 方法，获取内部所有内容，字符串形式

### 花瓣网数据渲染上树步骤

1. 定义一个高度映射数组
2. 格式化模板，也就是用封装的引擎函数替换想要的数据
3. 定义最矮的列高度，得到索引值
4. 上树

5. 对应`height_arr`中的对应项也发生变化

```
// 获取tpl
var tpl = $("#tpl").html();
// 发送ajax
$.ajax({
	url: "/data/1.json", 
	dataType: "json",
	success: function(data) {
		// 定义一个高度映射数组 
		var height_arr = new Array(5).fill(0);
		for (var i = 0; i < data.pins.length; i++) {
			// 格式化模板
			var str = format(tpl, data.pins[i]);
			// 要根据哪个列的高度最矮 
			var minIdx = getMinIdx(height_arr);
			// 上树
			$("ul li").eq(minIdx).append(str);
			// li高度已经发生了变化 要让height_arr中的对应项也发生变化
			height_arr[minIdx] += parseInt(236 * data.pins[i].file.height / data.pins[i].file.width) + 104; 
			console.log(data.pins[i].file.width);
		}
		console.log(height_arr)
	}
});
```

# ==Ajax 分页==

## 1. 概念

有些数据，比如学生的成绩表，比如招聘网站的求职内容，职位内容。如果数量太多，则需要分页显示。

此时我们可以通过`AJAX`来完成。可以点击上一页和下一页进行不同数据的切换，造成“分页”效果。

## 2. 代码块

```
// 获取模板
var tpl = $("#tpl").html();
// 获取list元素
var $list = $("#list");
// 获取上下按钮
var $prev = $("#prev");
var $next = $("#next");
// 定义一个函数 用于复用代码
function sendAjax(idx) {
	// 发送ajax 请求下一页的数据
	$.ajax({
		url: "/data/" + idx + ".json",
		dataType: "json",
		success: function(data) {
			// 清除原来的内容
			$list.empty();
			// 循环格式化
			for (var i = 0; i < data.postList.length; i++) {
				// 字典修正
				data.postList[i].type = data.postList[i].postType.slice(4, 6);
				// 格式化
				var val = format(tpl, data.postList[i]);
				$list.append(val);
			}
		}
	});
}
// 提取信号量
var idx = 1;
sendAjax(idx);
// 添加点击事件
$next.click(function() {
	idx++;
	console.log(idx);
	// 判定是否越界
	if (idx > 4) {
		id
		return;x = 4;
	}
	sendAjax(idx);
});

// 添加点击事件
$prev.click(function() {
	idx--;
	console.log(idx);
	// 判定是否越界
	if (idx < 1) {
		idx = 1;
		return;
	}
	sendAjax(idx);
});
/* 字符串替换方法
	* @tpl 模板字符串 符合<%xxx.xxx.xxx%>格式
	* @dic 字典对象 必须有tpl中xxx.xxx.xxx层级
	* @return 返回值 格式化完毕之后的字符串
	*/
function format(tpl, dic) {
	// 调用replace方法
	return tpl.replace(/<%([a-zA-Z_0-9]+(\.[a-zA-Z_0-9]+)*)%>/g, function(match, $1) {
		var arr = $1.split(".");
		var result = dic;
		for (var i = 0; i < arr.length - 1; i++) {
			result = result[arr[i]];
		}
		return result[arr[i]];
	});
}
```

# ==Ajax 前进后退==

## 1. 概念

虽然分页效果有了，用户一旦点击浏览器的后退按钮时，真的就退回上一个页面中。而不是上一次操作。

这就是AJAX不会刷新页面的弊端。它`没有更改历史记录`。

**（1）思路**

AJAX不刷新页面，不更改历史记录。

我们可以人工修改历史记录。

H5中，增强了一个BOM对象：history

`前进后退功能`：其实并没有AJAX的关系，纯粹是H5中History对象的事。

## 2. history 接口

### pushState()

`history.pushState()`

该方法用于向历史记录中新增一项

- `data`：数据对象 用于记录一些信息 可以在onpopstate事件触发时 事件对象中得到
- `title`：新页面的标题 通常会忽略
- `url`：新页面的URL

### replaceState()

`history.replaceState()`

该方法用于替换当前的历史记录

- `data`：数据对象 用于记录一些信息 可以在onpopstate事件触发时 事件对象中得到
- `title`：新页面的标题 通常会忽略
- `url`：新页面的URL

window有一个事件：`onpopstate` 该事件会在浏览器的前进和后退中触发 

## 3. popstate 事件

每当同一个文档的浏览历史（即`history`对象）出现变化时，就会触发`popstate`事件。

注意，仅仅调用`pushState()`方法或`replaceState()`方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用`History.back()`、`History.forward()`、`History.go()`方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。

使用的时候，可以为`popstate`事件指定回调函数。

```
window.onpopstate = function (event) {
  console.log('location: ' + document.location);
  console.log('state: ' + JSON.stringify(event.state));
};

// 或者
window.addEventListener('popstate', function(event) {
  console.log('location: ' + document.location);
  console.log('state: ' + JSON.stringify(event.state));
});
```

回调函数的参数是一个`event`事件对象，它的`state`属性指向`pushState`和`replaceState`方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数）。上面代码中的`event.state`，就是通过`pushState`和`replaceState`方法，为当前 URL 绑定的`state`对象。

这个`state`对象也可以直接通过`history`对象读取。

```
var currentState = history.state;
```

注意，页面第一次加载的时候，浏览器不会触发`popstate`事件。

## 5. 代码块

```
// 获取模板
var tpl = $("#tpl").html();
// 获取list元素
var $list = $("#list");
// 获取上下按钮
var $prev = $("#prev");
var $next = $("#next");
// 定义一个函数 用于复用代码
function sendAjax(idx) {
	// 发送ajax 请求下一页的数据
	$.ajax({
		url: "/data/" + idx + ".json",
		dataType: "json",
		success: function(data) {
			// 清除原来的内容
			$list.empty();
			// 循环格式化
			for (var i = 0; i < data.postList.length; i++) {
				// 字典修正
				data.postList[i].type = data.postList[i].postType.slice(4, 6);
				// 格式化
				var val = format(tpl, data.postList[i]);
				$list.append(val);
			}
		}
	});
}
// 提取信号量
var idx = 1;
sendAjax(idx);
// replaceState一次
history.replaceState({idx: idx}, "", "#" + idx);
// 添加点击事件
$next.click(function() {
	idx++;
	console.log(idx);
	// 判定是否越界
	if (idx > 4) {
		id
		return;x = 4;
	}
	sendAjax(idx);
	// 同步的新增一个历史记录
	history.pushState({idx: idx}, "", "#" + idx);
});

// 添加点击事件
$prev.click(function() {
	idx--;
	console.log(idx);
	// 判定是否越界
	if (idx < 1) {
		idx = 1;
		return;
	}
	sendAjax(idx);
});
/* 字符串替换方法
	* @tpl 模板字符串 符合<%xxx.xxx.xxx%>格式
	* @dic 字典对象 必须有tpl中xxx.xxx.xxx层级
	* @return 返回值 格式化完毕之后的字符串
	*/
function format(tpl, dic) {
	// 调用replace方法
	return tpl.replace(/<%([a-zA-Z_0-9]+(\.[a-zA-Z_0-9]+)*)%>/g, function(match, $1) {
		var arr = $1.split(".");
		var result = dic;
		for (var i = 0; i < arr.length - 1; i++) {
			result = result[arr[i]];
		}
		return result[arr[i]];
	});
}

// 监听url的变化
window.onpopstate = function(e) {
	console.log(e.state.idx);
	sendAjax(e.state.idx);
}
```

下面是思路步骤：

- 在发送AJAX的时候，同时新增一条历史记录
  - 此时，确实可以点击后退按钮，但是页面中的内容不会发生变化

```
// 添加点击事件
$next.click(function() {
	idx++;
	console.log(idx);
	// 判定是否越界
	if (idx > 4) {
		id
		return;x = 4;
	}
	sendAjax(idx);
	// 同步的新增一个历史记录
	history.pushState({idx: idx}, "", "#" + idx);
});
```

- 想办法在后退按钮被点击时 触发事件 并重新发送ajax
  - 此时，确实可以在点击后退按钮与前进按钮时更新数据。但是回退到第一个页面时，会报错。

```
// 监听url的变化
window.onpopstate = function(e) {
	console.log(e.state.idx);
	sendAjax(e.state.idx);
}
```

- 因为在访问首个页面时，没有增加对应的信息。所以onpopstate事件触发，但是找不到应该请求谁。所以，干脆删掉它。因为已经有一个页面与它一模一样。
  - 在新加载该页面的时候将当前的原始的URL替换掉，此时，再后退，也退不到原始页面中。因为它已经从历史记录中消失。

```
sendAjax(idx);
// replaceState一次
history.replaceState({idx: idx}, "", "#" + idx);
```

# ==Ajax 聊天室==

## 1. 概念

浏览器A发送消息给服务器

服务器接收消息。

浏览器B发送消息给服务器

服务器接收消息。

浏览器C发送请求，请求服务器：“有没有其它用户的消息，有就发给我。”

服务器将消息发给C

浏览器C发送请求，请求服务器：“有没有其它用户的消息，有就发给我。”

服务器：“没有”。

浏览器C发送请求，请求服务器：“有没有其它用户的消息，有就发给我。”

服务器：“没有”。

浏览器C发送请求，请求服务器：“有没有其它用户的消息，有就发给我。”

服务器：“没有”。

浏览器C发送请求，请求服务器：“有没有其它用户的消息，有就发给我。”

服务器：“没有”。

浏览器A发消息，服务器接收消息。

浏览器C发送请求，请求服务器：“有没有其它用户的消息，有就发给我。”

服务器：“有”。 服务器将消息发给C

## 2. Ajax 轮询

定时获取新的其它用户发言

```
// 每隔一秒发送一个请求 
setInterval(function() {
	// 发送ajax
	$.ajax({
		url: "/action/getMsg",
		data: {
			idx: idx
		},
		type: "get",
		dataType: "json",
		success: function(data) {
			for (var i = 0; i < data.data.length; i++) {
				idx++;
				var li = document.createElement("li");
				li.innerHTML = data.data[i];
				$list.append(li);
			}
		}
	});
}, 1000);
```

## 3. 实现

- 第一步 实现发送数据接口
  - 点击按钮将用户的发言内容发送给服务器

- 第二步 实现请求数据接口
  - 通过AJAX轮询技术定时获取新的其它用户发言

1. 前端发送数据

```
// 当用户点击发送按钮时
$send.click(function() {
	// 获取input的内容
	var val = $inp.val();
	// 判定 用户如果没有输入内容就点击按钮 禁止用户发送信息
	if (!val) {
		return;
	}
	// 发送ajax
	$.ajax({
		url: "/action/sendMsg",
		data: {
			msg: val
		},
		type: "get",
		dataType: "json",
		success: function(data) {
			console.log(data);
		}
	});
});
```

2. 后端书写接口获取数据，并通知前端已接收

```
// 书写接口
if (url_obj.pathname === "/action/sendMsg" && method === "get") {
	// 获取前端提交过来的数据
	var msg = url_obj.query.msg;
	// 存储
	arr.push(msg);
	// 返回给前端一个消息
	res.end(JSON.stringify({
		error: 0,
		data: "接收成功"
	}));
	console.log(arr);
	return;
} 
```

3. 前端每隔一秒发送一个请求 （ Ajax 轮询 ）

```
// 每隔一秒发送一个请求 
setInterval(function() {
	// 发送ajax
	$.ajax({
		url: "/action/getMsg",
		data: {
			idx: idx
		},
		type: "get",
		dataType: "json",
		success: function(data) {
			for (var i = 0; i < data.data.length; i++) {
				idx++;
				var li = document.createElement("li");
				li.innerHTML = data.data[i];
				$list.append(li);
			}
		}
	});
}, 1000);
```

4. 后端书写接口返回新的其他数据内容

```
// 书写接口
if (url_obj.pathname === "/action/getMsg" && method === "get") {
	// 先获取idx
	var idx = url_obj.query.idx;
	// 获取新数组
	var newArr = arr.slice(idx);
	// 设置响应头
	res.setHeader("content-type", "text/plain;charset=utf-8");
	// 将所有数据都发给前端
	res.end(JSON.stringify({
		error: 0,
		data: newArr
	}));
	return;
}
```

# ==Ajax 2.0==

## 1. FormData 对象

这是一个AJAX2.0中新增的构造函数。

是window的属性，用于表单序列化。

详细请看《7. 浏览器对象模型》

![image-20190418213123016](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/warb3.png)

### 概述

表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程，构造和编辑表单键值对，然后通过`XMLHttpRequest.send()`方法发送。浏览器原生提供了 FormData 对象来完成这项工作。

FormData 首先是一个构造函数，用来生成实例。

```
var formdata = new FormData(form);
```

`FormData()`构造函数的参数是一个表单元素，这个参数是可选的。如果省略参数，就表示一个空的表单，否则就会处理表单元素里面的键值对。

下面是一个表单。

```
<form id="myForm" name="myForm">
  <div>
    <label for="username">用户名：</label>
    <input type="text" id="username" name="username">
  </div>
  <div>
    <label for="useracc">账号：</label>
    <input type="text" id="useracc" name="useracc">
  </div>
  <div>
    <label for="userfile">上传文件：</label>
    <input type="file" id="userfile" name="userfile">
  </div>
<input type="submit" value="Submit!">
</form>
```

我们用 FormData 对象处理上面这个表单。

```
var myForm = document.getElementById('myForm');
var formData = new FormData(myForm);

// 获取某个控件的值
formData.get('username') // ""

// 设置某个控件的值
formData.set('username', '张三');

formData.get('username') // "张三"
```

### 实例方法

FormData 提供以下实例方法。

- `FormData.get(key)`：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。
- `FormData.getAll(key)`：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。
- `FormData.set(key, value)`：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。
- `FormData.delete(key)`：删除一个键值对，参数为键名。
- `FormData.append(key, value)`：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。
- `FormData.has(key)`：返回一个布尔值，表示是否具有该键名的键值对。
- `FormData.keys()`：返回一个遍历器对象，用于`for...of`循环遍历所有的键名。
- `FormData.values()`：返回一个遍历器对象，用于`for...of`循环遍历所有的键值。
- `FormData.entries()`：返回一个遍历器对象，用于`for...of`循环遍历所有的键值对。如果直接用`for...of`循环遍历 FormData 实例，默认就会调用这个方法。

下面是`get()`、`getAll()`、`set()`、`append()`方法的例子。

```
var formData = new FormData();

formData.set('username', '张三');
formData.append('username', '李四');
formData.get('username') // "张三"
formData.getAll('username') // ["张三", "李四"]

formData.append('userpic[]', myFileInput.files[0], 'user1.jpg');
formData.append('userpic[]', myFileInput.files[1], 'user2.jpg');
```

下面是遍历器的例子。

```
var formData = new FormData();
formData.append('key1', 'value1');
formData.append('key2', 'value2');

for (var key of formData.keys()) {
  console.log(key);
}
// "key1"
// "key2"

for (var value of formData.values()) {
  console.log(value);
}
// "value1"
// "value2"

for (var pair of formData.entries()) {
  console.log(pair[0] + ': ' + pair[1]);
}
// key1: value1
// key2: value2

// 等同于遍历 formData.entries()
for (var pair of formData) {
  console.log(pair[0] + ': ' + pair[1]);
}
// key1: value1
// key2: value2
```

# ==图片预览==

## 1. 概念

图片预览指的是：在图片上传之前，预先查看图片在页面中的显示。

大的图片不如发 http 请求来获取（页面会非常大），小的图片可以转为 base64 ，不用发请求了

## 2. input 控件

`input`的`type`为`file`时，会显示一个选择文件控件，下面为控件属性：

- `type`：file
- `accept`：该属性决定可以选择的文件有哪些。属性值就是 MimeType。
- `multiple`：该属性决定是否可以同时选择多个文件。 属性值就是属性名

```
<input type="file" name="file" id="file" multiple>
```

## 3. change 事件

`change`事件当`<input>`、`<select>`、`<textarea>`的值发生变化时触发。它与`input`事件的最大不同，就是不会连续触发，只有当全部修改完成时才会触发，另一方面`input`事件必然伴随`change`事件。具体来说，分成以下几种情况。

- 激活单选框（radio）或复选框（checkbox）时触发。
- 用户提交时触发。比如，从下列列表（select）完成选择，在日期或文件输入框完成选择。
- 当文本框或`<textarea>`元素的值发生改变，并且丧失焦点时触发。

下面是一个例子。

```
// HTML 代码如下
// <select size="1" onchange="changeEventHandler(event);">
//   <option>chocolate</option>
//   <option>strawberry</option>
//   <option>vanilla</option>
// </select>

function changeEventHandler(event) {
  console.log(event.target.value);
}
```

## 4. 网页元素的事件属性

网页元素的事件属性（比如`onclick`和`onmouseover`），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。

```
<button id="myBtn" onclick="console.log(this.id)">点击</button>
```

上面的事件属性代码只有一个语句。如果有多个语句，使用分号分隔即可。

## 5. base64 编码

Base64是网络上最常见的用于传输8Bit[字节码](https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81/9953683)的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。可查看RFC2045～RFC2049，上面有MIME的详细规范。

Base64编码是从二进制到字符的过程，可用于在[HTTP](https://baike.baidu.com/item/HTTP)环境下传递较长的标识信息。例如，在Java Persistence系统Hibernate中，就采用了Base64来将一个较长的唯一[标识符](https://baike.baidu.com/item/%E6%A0%87%E8%AF%86%E7%AC%A6/7105638)（一般为128-bit的UUID）编码为一个字符串，用作HTTP[表单](https://baike.baidu.com/item/%E8%A1%A8%E5%8D%95/5380322)和HTTP GET URL中的参数。在其他应用程序中，也常常需要把二进制[数据编码](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BC%96%E7%A0%81/10173270)为适合放在URL（包括隐藏[表单域](https://baike.baidu.com/item/%E8%A1%A8%E5%8D%95%E5%9F%9F/3788809)）中的形式。此时，采用Base64编码具有不可读性，需要解码后才能阅读。

Base64由于以上优点被广泛应用于计算机的各个领域，然而由于输出内容中包括两个以上“符号类”字符（+, /, =)，不同的应用场景又分别研制了Base64的各种“变种”。为统一和规范化Base64的输出，Base62x被视为无符号化的改进版本。



## 6. 不允许访问本地资源

```
<input type="file" name="file" id="file" multiple> 

// 获取文件选择控件
var file = document.getElementById("file");
var img = document.getElementById("img");
// 监听change事件
file.onchange = function() {
	// 当文件更改时 会触发当前事件
	// 获取文件内容
	// console.log(file.value);
	// 如果直接设置file.value 将会报错 Not allowed to load local Source 
	img.src = file.value;
}
```

当浏览器报错：

```
Not allowed to load local resource
```

`chrome禁止本地浏览时加载本地其他文件`, 注意是本地浏览器中浏览时！ 比如 `input type="file"`点击访问文件操作是不允许的。详细请看下面  - 《获取文件的限制》

可以通过修改tomcat的server.xml来配置虚拟映射，让我们能通过服务器访问到本地资源

### 解除限制方案

- `方案一`：可以将项目部署在web服务器上，如tomcat，
  将目录移动到例如apache-tomcat-7.0.47\webapps\下，启动tomcat，然后浏览器打开后输入h ttp://localhost/...即可。

- `方案二`：设置浏览器，因为现在浏览器为了安全起见，一般都默认不能加载本地文件，其实我们设置一下就可以加载了。

  - Chrome：

    - 1、得到Chrome的安装路径，例如：C:\Program Files\Google\Chrome\Application

    - 2、在命令行窗口，输入安装路径，加上--allow-file-access-from-files参数，例如： Chrome installation path\chrome.exe --allow-file-access-from-files 。重新启动浏览器即可。

    -  3、在Chrome的快捷方式，右键->属性->目标的文本框中加上参数 --allow-file-access-from-files

      例："C:\Program Files \Google\Chrome\Application\chrome.exe" --allow-file-access-from-files

  - Firefox：

    - 1、在浏览器的地址栏输入“about:config”，回车
    - 2、在过滤器（filter）中搜索“security.fileuri.strict_origin_policy”
    - 3、将security.fileuri.strict_origin_policy设置为false
    - 4、关闭目前开启的所有Firefox窗口，然后重新启动Firefox。

## 7. 获取文件的限制

文件选择器`<input type="file">`用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的`value`属性，即文件必须是用户手动选取的，不能是脚本指定的。一旦用户选好了文件，脚本就可以读取这个文件。

文件控件节点（`<input type="file">`）的`files`属性，返回一个 FileList 实例对象。该对象是一个类似数组的成员，每个成员都是一个 `File 实例对象`。File 实例对象是一个特殊的 Blob 实例，增加了`name`和`lastModifiedDate`属性。详细请看《浏览器对象模型 - File 对象，FileList 对象，FileReader 对象》

```
// HTML 代码如下
// <input type="file" accept="image/*" multiple onchange="fileinfo(this.files)"/>

function fileinfo(files) {
  for (var i = 0; i < files.length; i++) {
    var f = files[i];
    console.log(
      f.name, // 文件名，不含路径
      f.size, // 文件大小，Blob 实例属性
      f.type, // 文件类型，Blob 实例属性
      f.lastModifiedDate // 文件的最后修改时间
    );
  }
}
```

除了文件选择器，拖放 API 的`dataTransfer.files`返回的也是一个FileList 对象，它的成员因此也是 File 实例对象。

## 8. FileReader

这是H5中新增的一个读取文件的读取器。

当初始化时，得到 FileReader 的实例 ，假设为下方代码中的变量`fd`。

该实例可以将文件对象转为`Base64字符串`。

> Base64就是一种基于64个可打印字符来表示二进制数据的方法  — 百度百科

```
// 获取文件选择控件
var file = document.getElementById("file");
var img = document.getElementById("img");
// 监听change事件
file.onchange = function() {
	// 当文件更改时 会触发当前事件
	// 获取文件内容
	// console.log(file.value);
	// 如果直接设置file.value 将会报错 Not allowed to load local Source 
	// img.src = file.value;
	// 获取文件本身的对象
	// console.log(file.files);
	// 根据文件对象 生成特殊路径
	var fd = new FileReader();
	fd.readAsDataURL(file.files[0]);
	// readAsDataURL执行完毕时 触发load事件
	fd.onload = function() {
		console.log(fd.result); // fd.result就是读取完毕的base64字符串 该字符串可以设置给img的src属性 就不用发送HTTP请求了
		img.src = fd.result;
	}
}
```

下方图片为 `fd.result` 输出结果 `base64字符串`，同时，图片也在浏览器上渲染显示出来了：

![](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/3pars.jpg)

###  FileReader.readAsDataURL()

`FileReader.readAsDataURL()`：读取完成后，`result`属性将返回一个 Data URL 格式（Base64 编码）的字符串，代表文件内容。对于图片文件，这个字符串可以用于`<img>`元素的`src`属性。注意，这个字符串不能直接进行 Base64 解码，必须把前缀`data:*/*;base64,`从字符串里删除以后，再进行解码。

```
/* HTML 代码如下
  <input type="file" onchange="previewFile()">
  <img src="" height="200">
*/

function previewFile() {
  var preview = document.querySelector('img');
  var file    = document.querySelector('input[type=file]').files[0];
  var fd  = new FileReader();

  fd.addEventListener('load', function () {
    preview.src = fd.result;
  }, false);

  if (file) {
    fd.readAsDataURL(file);
  }
}
```

上面代码中，用户选中图片文件以后，脚本会自动读取文件内容，然后作为一个 Data URL 赋值给`<img>`元素的`src`属性，从而把图片展示出来。

## 9. URL.createObjectURL()

`URL.createObjectURL`方法用来为上传/下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了`File`对象或`Blob`对象的 URL。

注意，每次使用`URL.createObjectURL`方法，都会在内存里面生成一个 URL 实例。如果不再需要该方法生成的 URL 字符串，为了节省内存，可以使用`URL.revokeObjectURL()`方法释放这个实例。

```
var div = document.getElementById('display');

function handleFiles(files) {
  for (var i = 0; i < files.length; i++) {
    var img = document.createElement('img');
    img.src = window.URL.createObjectURL(files[i]);
    div.appendChild(img);
    img.onload = function() {
      window.URL.revokeObjectURL(this.src);
    }
  }
}
```

上面代码中，一旦图片加载成功以后，为本地文件生成的 URL 字符串就没用了，于是可以在`img.onload`回调函数里面，通过`URL.revokeObjectURL`方法卸载这个 URL 实例。

###  下载文件

AJAX 请求时，如果指定`responseType`属性为`blob`，下载下来的就是一个 Blob 对象。

```
function getBlob(url, callback) {
  var xhr = new XMLHttpRequest();
  xhr.open('GET', url);
  xhr.responseType = 'blob';
  xhr.onload = function () {
    callback(xhr.response);
  }
  xhr.send(null);
}
```

上面代码中，`xhr.response`拿到的就是一个 Blob 对象。

### 生成 URL

浏览器允许使用`URL.createObjectURL()`方法，针对 Blob 对象生成一个临时 URL，以便于某些 API 使用。这个 URL 以`blob://`开头，表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与`data://URL`（URL 包含实际数据）和`file://URL`（本地文件系统里面的文件）都不一样。

```
var droptarget = document.getElementById('droptarget');

droptarget.ondrop = function (e) {
  var files = e.dataTransfer.files;
  for (var i = 0; i < files.length; i++) {
    var type = files[i].type;
    if (type.substring(0,6) !== 'image/')
      continue;
    var img = document.createElement('img');
    img.src = URL.createObjectURL(files[i]);
    img.onload = function () {
      this.width = 100;
      document.body.appendChild(this);
      URL.revokeObjectURL(this.src);
    }
  }
}
```

上面代码通过为拖放的图片文件生成一个 URL，产生它们的缩略图，从而使得用户可以预览选择的文件。

浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。

# ==同源限制==

## 1. 概述

> 浏览器安全的基石是“同源政策”（[same-origin policy](https://en.wikipedia.org/wiki/Same-origin_policy)）。很多开发者都知道这一点，但了解得不全面。

### 含义

1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。

最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”。所谓“同源”指的是“三个相同”。

> - 协议相同
> - 域名相同
> - 端口相同

举例来说，`http://www.example.com/dir/page.html`这个网址，协议是`http://`，域名是`www.example.com`，端口是`80`（默认端口可以省略），它的同源情况如下。

- `http://www.example.com/dir2/other.html`：同源
- `http://example.com/dir/other.html`：不同源（域名不同）
- `http://v2.www.example.com/dir/other.html`：不同源（域名不同）
- `http://www.example.com:81/dir/other.html`：不同源（端口不同）
- `https://www.example.com/dir/page.html`：不同源（协议不同）

### 目的

同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。

设想这样一种情况：A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息（比如存款总额）。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私信息就会泄漏。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。

由此可见，同源政策是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。

### 限制范围

随着互联网的发展，同源政策越来越严格。目前，如果非同源，共有三种行为受到限制。

> （1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。
>
> （2） 无法接触非同源网页的 DOM。
>
> （3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。

另外，通过 JavaScript 脚本可以拿到其他窗口的`window`对象。如果是非同源的网页，目前允许一个窗口可以接触其他网页的`window`对象的九个属性和四个方法。

- window.closed
- window.frames
- window.length
- window.location
- window.opener
- window.parent
- window.self
- window.top
- window.window
- window.blur()
- window.close()
- window.focus()
- window.postMessage()

上面的九个属性之中，只有`window.location`是可读写的，其他八个全部都是只读。而且，即使是`location`对象，非同源的情况下，也只允许调用`location.replace`方法和写入`location.href`属性。

虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面介绍如何规避上面的限制。

## 2. JSONP 跨域

静态资源不受同源策略限制，可以跨域。

AJAX受同源策略限制，不可以跨域。

> 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。

我们可以将静态资源的src指向接口地址。

静态资源标签有挺多，选择script标签。 script标签会执行代码。

```
<script type="text/javascript" src="http://localhost:3001/checkName?username=wanglaowu"></script>
```

此时，没有失败，并且有返回的数据：

![image-20190419024119216](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/9wfav.png)

但是报错：语法错误

![image-20190419024147960](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/fy78a.png)

这是因为该标签请求回来的`字符串被 script 标签尝试执行`，所以报错。

我们可以改一下返回内容：

```
res.end("aaa(" + JSON.stringify({
	error: 1,
	data: "抱歉，已经被占用"
}) + ")");
```

此时，依旧报错，但是这个错误是未定义错误，可以提前修改的： 提前定义一个该函数即可

```
function aaa(data) {
	console.log(data);
}
```

最终：成功得到对方服务器的结果：

![image-20190419024559859](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/e9lvy.png)

### JSONP 轮子

```
/*
 * jsonp函数用于发送jsonp请求 用于跨域
 * @url 决定发送的接口地址
 * @data 对象 对象中是本次携带的数据
 * @callback 执行的函数
 **/
var jsonp = function(url, data, callback) {
	// 定义变量 用于拼接query字符串
	var str = "";
	for (var i in data) {
		str += i + "=" + data[i] + "&"
	}
	// 去掉最后的&
	str.slice(0, -1);
	// 预先定义一个函数 该函数会被注册到全局中 也就是window上
	window[data.callback] = callback;
	// 写一个script标签 src指向url 同时携带数据
	var script = document.createElement("script");
	script.src = url + "?" + str;
	// 当js执行完毕 去掉script标签和这个全局函数
	script.onload = function() {
		// 删除全局的函数属性
		delete window[data.callback];
		// script标签移除
		document.body.removeChild(script);
	}
	// 上树 
	document.body.appendChild(script);
}
```

### JSONP 优缺点

- `优点`：它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制；它的`兼容性更好`，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持；并且在请求完毕后可以通过调用callback的方式回传结果。

- `缺点`：它只支持`GET`请求而不支持POST等其它类型的HTTP请求；它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。

## 3. CORS 通信

CORS 是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。相比 JSONP 只能发`GET`请求，CORS 允许任何类型的请求。

详情看《浏览器对象模型 - CORS 通信》

#  ==URL转码、解码==

## 1. 概念

URL里面是不可以出现中文的。

可是有些时候我们必须传递中文，我们就转码。

转码：将一种编码转为另一种编码方式。

## 2. 解析中文

```
encodeURIComponent(中文)
```

![image-20190419031202150](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/kzvnm.png)

## 3. 解析 URL 编码

```
decodeURIComponent(转码后的 URL 编码)
```

![image-20190419031340276](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/d7sbr.png)

# ==文件上传==

## 1. 概述

用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。

```
<input type="file" id="file" name="myFile">
```

前端提交文件，有两种方式：`表单提交`、`AJAX提交`。

## 2. 表单提交

表单的`action`必须有 指向一个后台处理接口

表单的`method` 必须是 `post`

表单的`enctype`必须是`multipart/form-data`

表单的文件控件必须是带`name`

表单中的`input`为`multiple`时，可以选择多个文件上传。

```
<form action="/uploadFile" method="post" enctype="multipart/form-data">
	<input type="file" name="myFile" id="file" multiple>
	<button id="btn">提交</button>
</form>
```

上面代码中， button 控件的 `type`属性默认是 `submit`，点击会触发`form`表单的`submit`事件，进行表单提交。

## 3. Ajax 提交

```
var file = document.getElementById('file').files[0];
var xhr = new XMLHttpRequest();

xhr.open('POST', 'myserver/uploads');
xhr.setRequestHeader('Content-Type', file.type);
xhr.send(file);
```

`file.type`：文件的 MIME 类型

