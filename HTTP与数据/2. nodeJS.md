# ==基本概念==

## 1. 服务器

服务器指的就是能够提供服务（响应）的机器。

比如：apache、nodejs、nginx等。

## 2. 浏览器

渲染页面给用户看到。也是 javaScipt 的一个运行环境

比如：chrome、IE、FireFox、safari、opera等

## 3. HTTP 协议

超文本传输协议。

用于规定浏览器与服务器之间的传递数据的规则。

### 协议的状态

HTTP 协议是一个无状态的协议

HTTP 协议建立的连接在目标达成之后，会断开。

### HTTP 请求

指的是浏览器根据HTTP协议发送了一个请求

请求的组成：

- `请求首行`：标记请求的URL和类型。
- `请求头`：标记请求的一些键值对每一组键值对都有特殊的作用。
- `请求空行`：就是一个空白行。用来分隔请求头和请求正文。
- `请求正文`：具体的携带的数据。`get` 请求没有请求正文。

### Connection

这是请求头中的一个字段 

如果值为：`close` 则处理完毕请求之后断开连接

如果值为：`keep-alive` 则保持一段时间的连接 如果这段时间内 又有同一个浏览器的请求来了 则复用该连接 如果没有 则一定时间后断开

## 4. 请求类型

请求分类型：`GET`、`POST`

### GET

`GET` 请求用于从服务器上“获取”内容。

特点：

- 没有请求正文
- 数据携带在 `url` 的 `query` 中
- 携带的数据量受地址栏长度限制
- 触发方式多： html 的一些资源加载标签、地址栏、表单、Ajax
- 携带的数据会被显示在 `url` 上 ，比如用户名和密码，不安全
- 复制 `url`地址分享时，默认为 `get`方式

### POST

`POST` 请求用于往服务器上“发送”内容。

特点：

- 具备请求正文
- 携带的数据存放在请求正文中
- 携带的数据量没有上限
- 触发方式少： 表单、Ajax
- `url`上不会显示用户密码，相对安全，浏览器控制台的请求正文里还是能看到用户名和密码，解决方案是加密

## 5. 缓存

指的是暂时存储

浏览器第一次访问www.icketang.com页面。

所有的服务器上的内容浏览器都没有。

请求数据回来之后，会暂时存储一段时间。

防止用户刷新的时候再次全部重新请求一次。

缓存的分类：

- 强制缓存：URL完全一致时，也会返回数据

- 协商缓存：在请求头中携带指定字段 发送到服务器 服务器根据指定的字段 查询资源是否发生过变化

## 4. URL

`URL`：统一资源定位符，用于定位资源

```
https://www.baidu.com/
https://localhost:3000/flappybird/index.html?a=1&b=2&c=3#ccc
```

### URL 对象

URL 字符串是结构化的字符串，包含多个含义不同的组成部分。 解析字符串后返回的 URL 对象，每个属性对应字符串的各个组成部分。

`url` 模块提供了两套 API 来处理 URL：一个是旧版本遗留的 API，一个是实现了 [WHATWG标准](http://nodejs.cn/s/fKgW8d)的新 API。

遗留的 API 还没有被废弃，保留是为了兼容已存在的应用程序。 新的应用程序应使用 WHATWG 的 API。

- 使用 WHATWG 的 API 解析 URL 字符串：

```
const myURL =
  new URL('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash');
```

- 使用遗留的 API 解析 URL 字符串：

```
const url = require('url');
const myURL =
  url.parse('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash');
```

### 组成分析

- `协议`：https、http、ftp、file

- `域名`：www.baidu.com
  - 域名是 IP 地址的便于人类记忆版，输入时需要 
  - 本地 IP 一般使用 `localhost`访问
- `端口`：80、8080、3000 共：0~65535
  - 一般默认端口是 80 ，会做隐藏处理
  - https 协议对应的端口是 443，也会做隐藏处理
  - 端口是指操作系统中规定的虚拟端口，每一个端口可以被一个应用程序所使用，进行提供一些功能，例如服务器程序一般使用 3000端口，不会做隐藏处理
- `pathname`： /flappybird/index.html
  - `/`开头为根目录开始查找，分为两个情况，也称绝对路径
  - 绝对路径：
    - 在服务器访问环境（`地址栏输入`）下，会从端口号所在程序（比如服务器程序）文件作为根目录查找，开头为 `/`；
    - 在后台环境（本地主机环境下或者为`执行代码时`）下，会从程序文件所在的盘符根目录查找，开头为 `/`
  - 相对路径：
    - 根据自身文件为根目录进行查找，开头不能为 `/`，转为相对路径要去掉 `/`
    - `../`跳出当前目录，`./`为当前目录

- `query`：a=1&b=2&c=3 、 username=wanglaowu&password=123
  - `query`前面的问号是用来分割路径和 `query`
  - 里面的内容是 `get`方式请求时携带的数据，例如用户名和密码

- `hash`： ccc
  - 以 `#`分割 `url` 里 `hash` 前面的内容
  - 一般`a`标签的`href`地址配合`ID属性`来做定点跳转锚点

![image-20190405020019571](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/l2zra.png)

## 5. 地址栏按下回车后

浏览器起始：应该是一个空白页。通过地址栏的内容的改变，发出请求。得到页面。

用户输入www.icketang.com并按下回车：

- 浏览器接收到www.icketang.com 开始解析成URL。
- 根据URL找到对应的服务器的IP地址
  - 找浏览器的缓存

  - 找系统缓存

  - 找路由器缓存

  - 找DNS 
    - DNS：Domain Name Server

    - 全球一共13台。
- 根据IP地址发起TCP连接请求（三次握手） 等连接成功之后 把对应的内容发送过去（发送请求）
- 服务器开始运行 根据你的请求进行对应的响应 传递数据完毕之后 断开连接
  - 沿着tcp连接通道返回数据
  - 如果请求的是静态资源：HTML文件、CSS文件、JS文件 则返回静态资源。
  - 如果请求的是接口：则执行并返回结果（结果可能不一致，所以也叫做动态资源）
- 浏览器接收到后端的响应 得到页面的源代码 发现是一个html文件 开始按照HTML的规则进行解析，解析过程：
  - 解析到link标签，发出一个HTTP请求 
  - 解析到img标签，发出一个HTTP请求
  - 解析到script标签，发出一个HTTP请求
- 解析完毕 用户看到页面了

## 6. Router 路由

### 概念

路由器（[Router](https://baike.baidu.com/item/Router)），是连接[因特网](https://baike.baidu.com/item/%E5%9B%A0%E7%89%B9%E7%BD%91/114119)中各[局域网](https://baike.baidu.com/item/%E5%B1%80%E5%9F%9F%E7%BD%91/98626)、[广域网](https://baike.baidu.com/item/%E5%B9%BF%E5%9F%9F%E7%BD%91/422004)的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。 路由器是[互联网](https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91)络的枢纽，"[交通警察](https://baike.baidu.com/item/%E4%BA%A4%E9%80%9A%E8%AD%A6%E5%AF%9F/22724)"。[目前](https://baike.baidu.com/item/%E7%9B%AE%E5%89%8D/9488911)路由器已经广泛应用于各行各业，各种不同档次的[产品](https://baike.baidu.com/item/%E4%BA%A7%E5%93%81/105875)已成为实现各种[骨干网](https://baike.baidu.com/item/%E9%AA%A8%E5%B9%B2%E7%BD%91/7371439)内部连接、骨干网间互联和骨干网与[互联网](https://baike.baidu.com/item/%E4%BA%92%E8%81%94%E7%BD%91/199186)互联互通业务的主力军。[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1/363497)和交换机之间的主要区别就是交换机发生在[OSI参考模型](https://baike.baidu.com/item/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B)第二层（[数据链路层](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/4329290)），而路由发生在第三层，即[网络层](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%B1%82/4329439)。这一区别决定了[路由](https://baike.baidu.com/item/%E8%B7%AF%E7%94%B1/363497)和交换机在移动信息的过程中需使用不同的控制信息，所以说两者实现各自功能的方式是不同的。

路由器（Router）又称[网关设备](https://baike.baidu.com/item/%E7%BD%91%E5%85%B3%E8%AE%BE%E5%A4%87/4932038)（Gateway）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个[子网](https://baike.baidu.com/item/%E5%AD%90%E7%BD%91)。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成。因此，路由器具有判断[网络地址](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80/9765459)和选择IP[路径](https://baike.baidu.com/item/%E8%B7%AF%E5%BE%84/1081474)的功能，它能在多[网络互联](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94/10501073)环境中，建立灵活的连接，可用完全不同的数据分组和[介质](https://baike.baidu.com/item/%E4%BB%8B%E8%B4%A8/5419484)访问方法连接各种子网，路由器只接受源站或其他路由器的信息，属[网络](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C)层的一种互联设备。

### express 中的 Router

用于确定应用程序如何响应对特定端点的客户机请求，包含一个 URI（或路径）和一个特定的 HTTP 请求方法（GET、POST 等）。

每个路由可以具有一个或多个处理程序函数，这些函数在路由匹配时执行。

路由定义采用以下结构：

```
app.METHOD(PATH, HANDLER)
```

- `app` 是 `express` 的实例。
- `METHOD` 是 [HTTP 请求方法](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol)。
- `PATH` 是服务器上的路径。
- `HANDLER` 是在路由匹配时执行的函数。

# ==初识 node.js==

## 1. 历史

Node.js是目前非常火热的技术，但是它的诞生经历却很奇特。

众所周知，在Netscape设计出JavaScript后的短短几个月，JavaScript事实上已经是前端开发的唯一标准。

后来，微软通过IE击败了Netscape后一统桌面，结果几年时间，浏览器毫无进步。（2001年推出的古老的IE 6到今天仍然有人在使用！）

没有竞争就没有发展。微软认为IE6浏览器已经非常完善，几乎没有可改进之处，然后解散了IE6开发团队！而Google却认为支持现代Web应用的新一代浏览器才刚刚起步，尤其是浏览器负责运行JavaScript的引擎性能还可提升10倍。

先是Mozilla借助已壮烈牺牲的Netscape遗产在2002年推出了Firefox浏览器，紧接着Apple于2003年在开源的KHTML浏览器的基础上推出了WebKit内核的Safari浏览器，不过仅限于Mac平台。

随后，Google也开始创建自家的浏览器。他们也看中了WebKit内核，于是基于WebKit内核推出了Chrome浏览器。

Chrome浏览器是跨Windows和Mac平台的，并且，Google认为要运行现代Web应用，浏览器必须有一个性能非常强劲的JavaScript引擎，于是Google自己开发了一个高性能JavaScript引擎，名字叫V8，以BSD许可证开源。

现代浏览器大战让微软的IE浏览器远远地落后了，因为他们解散了最有经验、战斗力最强的浏览器团队！回过头再追赶却发现，支持HTML5的WebKit已经成为手机端的标准了，IE浏览器从此与主流移动端设备绝缘。

浏览器大战和Node有何关系？

话说有个叫Ryan Dahl的歪果仁，他的工作是用C/C++写高性能Web服务。对于高性能，异步IO、事件驱动是基本原则，但是用C/C++写就太痛苦了。于是这位仁兄开始设想用高级语言开发Web服务。他评估了很多种高级语言，发现很多语言虽然同时提供了同步IO和异步IO，但是开发人员一旦用了同步IO，他们就再也懒得写异步IO了，所以，最终，Ryan瞄向了JavaScript。

因为JavaScript是单线程执行，根本不能进行同步IO操作，所以，JavaScript的这一“缺陷”导致了它只能使用异步IO。

选定了开发语言，还要有运行时引擎。这位仁兄曾考虑过自己写一个，不过明智地放弃了，因为V8就是开源的JavaScript引擎。让Google投资去优化V8，咱只负责改造一下拿来用，还不用付钱，这个买卖很划算。

于是在2009年，Ryan正式推出了基于JavaScript语言和V8引擎的开源Web服务器项目，命名为Node.js。虽然名字很土，但是，Node第一次把JavaScript带入到后端服务器开发，加上世界上已经有无数的JavaScript开发人员，所以Node一下子就火了起来。

在Node上运行的JavaScript相比其他后端开发语言有何优势？

最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。

其次，JavaScript语言本身是完善的函数式语言，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ECMAScript 6标准，可以完全满足工程上的需求。

> 我还听说过 io.js，这又是什么鬼？

因为Node.js是开源项目，虽然由社区推动，但幕后一直由Joyent公司资助。由于一群开发者对Joyent公司的策略不满，于2014年从Node.js项目fork出了io.js项目，决定单独发展，但两者实际上是兼容的。

然而中国有句古话，叫做“分久必合，合久必分”。分家后没多久，Joyent公司表示要和解，于是，io.js项目又决定回归Node.js。

具体做法是将来io.js将首先添加新的特性，如果大家测试用得爽，就把新特性加入Node.js。io.js是“尝鲜版”，而Node.js是线上稳定版，相当于Fedora Linux和RHEL的关系。

## 2. 简介

NodeJS不是一门语言。是一个JavaScript语言的执行环境。之前，JavaScript的宿主环境是浏览器。现在多了一个Node。

NodeJS是一个基于Chrome浏览器V8引擎上的JS运行环境。可以独立运行JS。

Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 

Node.js开发的目的就是为了用JavaScript编写Web服务器程序。

官网：https://nodejs.org/en/

### 下载 nodeJS 环境包

想要使用 nodeJS， 需要先下载它的环境包（上面的官网里有下载地址），这个环境包自带了 npm 环境包。

安装的位置实际上是`/usr/local/bin/node`

![image-20190421104403409](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/p20a6.png)

![image-20190421101714249](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/x6v7a.png)

### node 命令

创建一个JS文件：helloworld.js

```
console.log("helloworld");
```

执行顺序：

- 打开命令面板
- 切换到当前的js文件所在目录
- 调用`node命令`运行JS文件 `node hellworld.js`

![image-20190405032832491](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/dwths.png)

### 特点

- 单线程
- 非阻塞I/O
- 事件驱动

单线程：指的就是整个程序只有一个线程负责调度。

非阻塞I/O:

I: input  输入   向内存中输入内容

O: output  输出   从内存中向外输出内容

事件驱动：当I/O完成的时候，触发一个事件，通过事件驱动整个程序的运行

## 3. 模块化

NodeJS一般进行模块化开发，属于后端模块化。

### 前后端模块化区别

- 前端模块化：

`sea.js`  遵循`CMD`规范，异步加载模块

`require.js` 遵循`AMD`规范，异步加载模块

- 后端模块化：

NodeJS  遵循`CommonJS`规范

`CommonJS`规范真的是同步加载规范

NodeJS的模块分两种：核心模块、第三方模块。

### 核心模块

核心模块指的是NodeJS天生自带的模块。

常用的有：`http`、`https`、`url`、`fs`、`querystring`等。

所有的核心模块：<https://nodejs.org/dist/latest-v10.x/docs/api/>

![image-20190405033502396](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/4xxer.png)

### 第三方模块

所有的非核心模块都被统一称为第三方模块。

所有的第三方模块的网站：<https://www.npmjs.com/>

![image-20190405033444636](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/f3335.png)

**（1）定义模块**

定义模块：每一个JS文件都是一个NodeJS模块。此时不需要使用`define`， nodeJS 会自动添加一层`define`外壳包裹

**（2）引入模块**

通过`require`函数进行模块的引入

`moduleName` 如果是核心模块直接写名称。如果是第三方模块则必须以./开头，除非放在`node_modules`，不然的话，引擎会认为这是个核心模块，而核心模块里面找不到此第三方模块。

```
var b = require("./b.js")
```

**（3）node_modules 文件夹**

该文件夹用于存放所有的NodeJS第三方模块。

该文件夹的作用是简化模块的引入

引入一个`b.js`

```
var b = require("./b.js"); // 成功
var b = require("b.js");  // 失败
var b = require("./b"); // 成功
```

之所以不加./会失败的原因：NodeJS 误以为要引入一个核心模块。

该文件夹还有一个特点： `可以在之前目录层级的任意一级`

**(4) 暴露内容**

通过以下三种方式暴露内容：

- `exports`打点添加属性

- `module.exports`打点添加属性

- `module.exports`赋值

```
exports.a = 100;
module.exports.b = 200;
module.exports = {
	a: 100,
	b: 200,
	c: 300
}
```

### 前端 or 后端模块化？

如何判断一个模块是前端模块化还是后端模块化（这里特指 nodeJS 模块）？

- `后端模块化`：当通过`node`命令来启动服务器文件时，此文件就是 nodeJS模块。从此文件开始的所有通过`requery`方法引入的模块和其他依赖模块（依赖的依赖等等有引入关系的文件）都是 nodeJS模块 。无需书写`define`，因为 nodeJS 会在启动时给所有模块隐式添加`define`壳。

- `前端模块化`：前端模块化有ES6 、 seaJS等等方式，在遵循 commJS规范的模块化开发中，只有书写 `define`才是一个模块化文件

## 4. node 服务器的两个目录

NodeJS运行文件的时候是以模块化的工作方式来运行。

当我们调用node命令的时候，并不是直接运行对应文件，而是先查询依赖，并把每一个依赖的js文件都打包成模块，再运行。

![image-20190419031708097](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/40m17.png)

当node运行它的时候，先把里面的所有依赖都加载完毕，并封装成模块。

所以，其实，运行的时候是在运行以下代码：

```
define(function(require, module, exports, __dirname, __filename) {
  var a = 10;
});
```

- `__dirname`：该变量指向一个地址，地址就是该`模块目录`所在的绝对路径
- `__filename`：该变量指向一个地址，地址就是该`模块文件`的绝对路径

### process 对象

`process` 对象是一个全局变量（由 node API 提供），它提供有关当前 Node.js 进程的信息并对其进行控制。 作为一个全局变量，它始终可供 Node.js 应用程序使用，无需使用 `require()`。

- `process.cwd()`：输出当前的程序的工作目录

![image-20190419032243968](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/g2pz3.png)

# ==fs 模块==

## 1. 介绍

```
// 引入 fs 模块
var fs = require( "fs" )
```

Node.js内置的`fs`模块就是文件系统模块，负责读写文件。

和所有其它JavaScript模块不同的是，`fs`模块同时提供了异步和同步的方法。

`fs` 模块提供了一个 API，用于以模仿标准 POSIX 函数的方式与文件系统进行交互。

## 2. 异步读取文件

`fs.readFile( filePath, callback )`

该方法用于读取文件内容，返回 data

- `filePath`：目标文件的路径

- `options`： 是字符串，则它指定字符编码

- `callback`：读取完毕之后的回调函数

  - `err`: 读取过程中可能出现的异常 如果有异常 err是一个异常对象 如果没有异常 err是null

  - `data`：如果有异常 undefined  如果没有异常 就是读取到的目标文件的内容

```
// 引入 fs 模块
var fs = require( "fs" )

// 读取文件
fs.readFile( "index.html", “utf-8”, function ( err, data ) {
    // 判断是否读取到文件
    if ( err ) {
        console.log( "没有相关数据" )
    }
    console.log( data )
} )

console.log( 123 )
```

![image-20190405105708573](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/b37lt.png)

### data.toString()

默认 data 使用 buffer 格式文件，转为字符串的话，需要调用`buf.toString()`方法，将 `buf` 解码成字符串，详细解读，[点我](<http://nodejs.cn/api/buffer.html#buffer_buf_tostring_encoding_start_end>)。

> 文件、图片等在 nodeJS 中都是以二进制格式存在，表示为 file 对象，是一个特殊的 Bob对象。buffer 也是其中一种二进制格式（nodeJS中对二进制文件的特有格式）。
>
> 
>
> 图片一般转为 base64 格式可让 src 直接赋值。
>
> Blob 对象表示一个二进制文件的数据内容。
>
> Base64 就是一种基于64个可打印字符来表示二进制数据的方法  — 百度百科

```
console.log( data.toString() )
```

![image-20190405110113863](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/78bj4.png)

## 3. 同步读取文件

`fs.readFileSync( filePath, options )`

除了标准的异步读取模式外，`fs`也提供相应的同步读取函数。同步读取的函数和异步函数相比，多了一个`Sync`后缀，并且不接收回调函数，函数直接返回结果 data。

```
// 同步读取文件
try {
    fs.readFileSync( "index.html", "utf-8" )
} catch ( err ) {
    console.log( "没有相关数据" )
}
```

使用`try..cath`代码块，有错误时，不中断代码的执行

## 3. 写文件

`fs.appendFile( filePath, content, callback )`

用于向文件中追加内容（如果文件不存在会进行创建）返回追加的内容，data

- `filePath`：目标文件

- `content`：要追加的内容

- `callback`： 回调函数

```
// 创建 / 追加文件
fs.appendFile( "index.html", "<div>haha</div>", function ( err, data ) {
    console.log( err )
} )
```

![image-20190405112226836](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/cnsj0.png)

## 4. 文件改名

`fs.rename()`

```
fs.rename(oldPath, newPath, fun)
```

- `oldPath`：需要改名的文件路径。
- `newPath`：改名后文件保存的路径。
- `fun`：回调

## 4. 删除文件

`fs.unlink(filePath, callback)`;

该方法用于删除文件，返回删除的文件 data

- `filePath`: 目标文件路径

- `callback`: 回调函数

```
// 引入fs
var fs = require("fs");
// 删除文件 
fs.unlink("a.txt", function(err,data) {
	console.log(err);
});
```

## 5. 文件夹操作

### 创建文件夹

`fs.mkdir(dirPath, callback)`

```
var fs = require("fs");
fs.mkdir("web", function(err,data) {
	console.log(err);
})
```

### 读取文件夹结构

`fs.readdir(dirPath, callback)`

当不是文件夹，而是一个文件时，会报错。返回此目录下的所有文件夹及文件名所组成的数组，包括自身。

- callback
  - `err`: 当不是一个文件夹时，报错
  - `arr`: 当不是一个目录文件夹时，undefined
    - 当是一个目录文件夹时，返回此目录下的所有文件夹及文件名所组成的数组

```
var fs = require("fs");
fs.readdir("./新建文件夹", function(err, arr) {
	console.log(err);
	console.log(arr); 
});
```

![image-20190405131555323](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/1om0w.png)

### 删除文件夹

`fs.rmdir(dirPath, callback)`

```
var fs = require("fs");
fs.rmdir("full", function(err,data) {
	console.log(err);
})
```

## 6. 判定文件状态

`fs.stat(target, callback)`

 该方法用于获取目标`stats`对象，没有返回值

- `target`: 目标路径

- `callback`: 回调函数
  - `err`: 获取目标状态过程中可能发生的异常
  - `stats`: 目标 `stats`对象 该对象的 isDirectory 方法可以返回布尔值

```
// 判定文件状态
fs.stat( "index.html", function ( err, stats ) {
	console.log( stat ) // 状态对象
    console.log( "index.html" + ( stat.isDirectory() ? "是" : "不是" ) + "一个文件夹"  )
} )
```

### stats 对象

`fs.Stats` 对象提供有关文件的信息。

从 `fs.stat()`、`fs.lstat()`和 `fs.fstat()` 及其同步方法返回的对象都属于此类型。 如果传给这些方法的 `options` 中的 `bigint` 为 true，则数值将为 `bigint` 型而不是 `number` 型。

```
Stats {
  dev: 2114,
  ino: 48064969,
  mode: 33188,
  nlink: 1,
  uid: 85,
  gid: 100,
  rdev: 0,
  size: 527,
  blksize: 4096,
  blocks: 8,
  atimeMs: 1318289051000.1,
  mtimeMs: 1318289051000.1,
  ctimeMs: 1318289051000.1,
  birthtimeMs: 1318289051000.1,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT,
  birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
```

`bigint` 的版本：

```console
Stats {
  dev: 2114n,
  ino: 48064969n,
  mode: 33188n,
  nlink: 1n,
  uid: 85n,
  gid: 100n,
  rdev: 0n,
  size: 527n,
  blksize: 4096n,
  blocks: 8n,
  atimeMs: 1318289051000n,
  mtimeMs: 1318289051000n,
  ctimeMs: 1318289051000n,
  birthtimeMs: 1318289051000n,
  atime: Mon, 10 Oct 2011 23:24:11 GMT,
  mtime: Mon, 10 Oct 2011 23:24:11 GMT,
  ctime: Mon, 10 Oct 2011 23:24:11 GMT,
  birthtime: Mon, 10 Oct 2011 23:24:11 GMT }
```

### isDirectory()

`stat.isDirectory()`：如果 `fs.Stats` 对象描述文件系统目录，则返回 `true`。

## 7. 删除非空目录案例

读取目标内的文件结构 得到一个数组

循环判定该数组的每一项是文件还是文件夹

如果是文件就删除

如果是文件夹 则读取目标内的文件结构 得到一个…… 

需要注意的是，因为`fs`的这些方法都是`非阻塞I/O`的。后来的代码的执行需要依赖前面的数据，所以需要将其变为` 阻塞 I/O` ：在方法名后面添加 `Sync`

```
// 引入 fs 模块
var fs = require( "fs" )

// 删除非空目录
function rm( dirPath ) {
    // 读取目录文件结构数组
    var arr = fs.readdirSync( dirPath )
    // 循环数组
    for ( var i = 0; i < arr.length; i ++ ) {
        // 获取文件状态
        var result = fs.statSync( dirPath + "/" + arr[i] ).isDirectory()
        console.log( result )
        // 判断结果
        if ( result ) {
            // 是一个目录,递归函数
            rm( dirPath + "/" + arr[i] )
        } else {
            // 是一个文件,进行删除
            fs.unlinkSync( dirPath + "/" + arr[i] )
        }
    }
    // 最后删除最开始的文件目录
    fs.rmdirSync( dirPath )
}
rm( "../node_modules" )
```

# ==http 模块==

## 1. 概念

要开发HTTP服务器程序，从头处理TCP连接，解析HTTP是不现实的。这些工作实际上已经由Node.js自带的`http`模块完成了。应用程序并不直接和HTTP协议打交道，而是操作`http`模块提供的`request`和`response`对象。

- `request`对象封装了HTTP请求，我们调用`request`对象的属性和方法就可以拿到所有HTTP请求的信息；

- `response`对象封装了HTTP响应，我们操作`response`对象的方法，就可以把HTTP响应返回给浏览器。

## 2. http.Server 类

`http.Server`属性指向一个类，表示 Web 服务器实例。

这个类继承了`net.Server`，而`net.Server`继承了 EventEmitter 接口，因此可以使用`server.on()`方法监听事情。最重要的一个事件是`request`，表示收到 HTTP 请求。

```
server.on('request', function (request, response) {
  response.end('Hello, world!');
} )
```

`server.listen()`方法用于启动 Web 服务。这个方法需要指定监听的端口，以及一个回调函数（启动后要做什么）。

```
server.listen(PORT, function() {
  console.log(`starting server at port ${PORT}`);
} )
```

此类具有以下的事件和属性：

- ['checkContinue' 事件](http://nodejs.cn/api/http.html#http_event_checkcontinue)
- ['checkExpectation' 事件](http://nodejs.cn/api/http.html#http_event_checkexpectation)
- ['clientError' 事件](http://nodejs.cn/api/http.html#http_event_clienterror)
- ['close' 事件](http://nodejs.cn/api/http.html#http_event_close)
- ['connect' 事件](http://nodejs.cn/api/http.html#http_event_connect_1)
- ['connection' 事件](http://nodejs.cn/api/http.html#http_event_connection)
- ['request' 事件](http://nodejs.cn/api/http.html#http_event_request)
- ['upgrade' 事件](http://nodejs.cn/api/http.html#http_event_upgrade_1)
- [server.close([callback])](http://nodejs.cn/api/http.html#http_server_close_callback)
- [server.listen()](http://nodejs.cn/api/http.html#http_server_listen)
- [server.listening](http://nodejs.cn/api/http.html#http_server_listening)
- [server.maxHeadersCount](http://nodejs.cn/api/http.html#http_server_maxheaderscount)
- [server.headersTimeout](http://nodejs.cn/api/http.html#http_server_headerstimeout)
- [server.setTimeout([msecs\][, callback])](http://nodejs.cn/api/http.html#http_server_settimeout_msecs_callback)
- [server.timeout](http://nodejs.cn/api/http.html#http_server_timeout)
- [server.keepAliveTimeout](http://nodejs.cn/api/http.html#http_server_keepalivetimeout)

## 3. http.createServer()

`http.createServer()`方法用于创建一个 Web 服务器，它的返回值就是一个`http.Server`实例。

`request`事件的回调函数，作为`createServer( fn )`方法的参数。

### 创建服务器

下面代码中最基本的服务器已经运行。但是没有办法进行任何的响应。

```
// 引入 http 模块
var http = require( "http" )

// 创建 server 服务器
var server = http.createServer( function ( req, res ) {

} )

// 设置监听端口
server.listen( 3000, function () {
    console.log( "服务器监听在了" + 3000 + "端口了" )
} )
```

## 4. request 事件

`request`事件的回调函数的两个参数，形参的名字随便取即可：

- 形参：`request`         实参：[IncomingMessage 对象](http://nodejs.cn/s/2RqpEw)
- 形参：`response`       实参：[ServerResponse 对象](http://nodejs.cn/s/rMXoZ1)

每次有请求时都会触发。 注意，每个连接可能有多个请求（在 HTTP Keep-Alive 连接的情况下）。

## 5. IncomingMessage 对象

`IncomingMessage` 对象由 `http.Server`类 或 `http.ClientRequest`类创建，并分别作为第一个参数传给 ['request'](http://nodejs.cn/s/2qCn57) 和 ['response'](http://nodejs.cn/s/qwaiK8) 事件。 它可用于访问响应状态、消息头、以及数据。

它实现了[可读流](http://nodejs.cn/s/YuDKX1)接口，还有以下额外的事件、方法、以及属性。

- ['aborted' 事件](http://nodejs.cn/api/http.html#http_event_aborted)
- ['close' 事件](http://nodejs.cn/api/http.html#http_event_close_2)
- [message.aborted](http://nodejs.cn/api/http.html#http_message_aborted)
- [message.complete](http://nodejs.cn/api/http.html#http_message_complete)
- [message.destroy([error])](http://nodejs.cn/api/http.html#http_message_destroy_error)
- [message.headers](http://nodejs.cn/api/http.html#http_message_headers)
- [message.httpVersion](http://nodejs.cn/api/http.html#http_message_httpversion)
- [message.method](http://nodejs.cn/api/http.html#http_message_method)
- [message.rawHeaders](http://nodejs.cn/api/http.html#http_message_rawheaders)
- [message.rawTrailers](http://nodejs.cn/api/http.html#http_message_rawtrailers)
- [message.setTimeout(msecs, callback)](http://nodejs.cn/api/http.html#http_message_settimeout_msecs_callback)
- [message.socket](http://nodejs.cn/api/http.html#http_message_socket)
- [message.statusCode](http://nodejs.cn/api/http.html#http_message_statuscode)
- [message.statusMessage](http://nodejs.cn/api/http.html#http_message_statusmessage)
- [message.trailers](http://nodejs.cn/api/http.html#http_message_trailers)
- [message.url](http://nodejs.cn/api/http.html#http_message_url)

### message.url

- 字符串

仅对从 [http.Server](http://nodejs.cn/s/jLiRTh) 获取的请求有效。
请求的 URL 字符串。它仅包含实际 HTTP 请求中存在的 URL。

要将 url 解析为其各个部分，可以使用 `require('url').parse(request.url)`：

```
$ node
> require('url').parse('/status?name=ryan')
Url {
  protocol: null,
  slashes: null,
  auth: null,
  host: null,
  port: null,
  hostname: null,
  hash: null,
  search: '?name=ryan',
  query: 'name=ryan',
  pathname: '/status',
  path: '/status?name=ryan',
  href: '/status?name=ryan'
}
```

### message.method

- 字符串

仅对从 [http.Server](http://nodejs.cn/s/jLiRTh) 获取的请求有效。

请求方法为字符串。 只读。 示例：`'GET'`、 `'DELETE'`。

### message.headers

- OBject

请求或响应的消息头对象。

消息头的名称和值的键值对。 消息头的名称都是小写的。

![image-20190407160653197](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/w2s59.png)

**（1）Connection**

这是请求头中的一个字段

- `close` 则处理完毕请求之后断开连接

- `keep-alive` 则保持一段时间的连接 如果这段时间内 又有同一个浏览器的请求来了 则复用该连接 如果没有 则一定时间后断开

## 6. ServerResponse 对象

此对象由 HTTP 服务器在内部创建，而不是由用户创建。 它作为第二个参数传给 ['request'](http://nodejs.cn/s/2qCn57) 事件。

响应继承自[流](http://nodejs.cn/s/kUvpNm)，并额外实现以下内容：

- ['close' 事件](http://nodejs.cn/api/http.html#http_event_close_1)
- ['finish' 事件](http://nodejs.cn/api/http.html#http_event_finish)
- [response.addTrailers(headers)](http://nodejs.cn/api/http.html#http_response_addtrailers_headers)
- [response.connection](http://nodejs.cn/api/http.html#http_response_connection)
- [response.end([data\][, encoding][, callback])](http://nodejs.cn/api/http.html#http_response_end_data_encoding_callback) 
- [response.finished](http://nodejs.cn/api/http.html#http_response_finished)
- [response.getHeader(name)](http://nodejs.cn/api/http.html#http_response_getheader_name)
- [response.getHeaderNames()](http://nodejs.cn/api/http.html#http_response_getheadernames)
- [response.getHeaders()](http://nodejs.cn/api/http.html#http_response_getheaders)
- [response.hasHeader(name)](http://nodejs.cn/api/http.html#http_response_hasheader_name)
- [response.headersSent](http://nodejs.cn/api/http.html#http_response_headerssent)
- [response.removeHeader(name)](http://nodejs.cn/api/http.html#http_response_removeheader_name)
- [response.sendDate](http://nodejs.cn/api/http.html#http_response_senddate)
- [response.setHeader(name, value)](http://nodejs.cn/api/http.html#http_response_setheader_name_value)
- [response.setTimeout(msecs[, callback])](http://nodejs.cn/api/http.html#http_response_settimeout_msecs_callback)
- [response.socket](http://nodejs.cn/api/http.html#http_response_socket)
- [response.statusCode](http://nodejs.cn/api/http.html#http_response_statuscode)
- [response.statusMessage](http://nodejs.cn/api/http.html#http_response_statusmessage)
- [response.write(chunk[, encoding\][, callback])](http://nodejs.cn/api/http.html#http_response_write_chunk_encoding_callback)
- [response.writeContinue()](http://nodejs.cn/api/http.html#http_response_writecontinue)
- [response.writeHead(statusCode[, statusMessage\][, headers])](http://nodejs.cn/api/http.html#http_response_writehead_statuscode_statusmessage_headers)
- [response.writeProcessing()](http://nodejs.cn/api/http.html#http_response_writeprocessing)

### response.setHeader()

- `name` 
- `value` 

为隐式响应头设置单个响应头的值。 如果此响应头已存在于待发送的响应头中，则其值将被替换。 在这里可以使用字符串数组来发送具有相同名称的多个响应头。 非字符串值将被原样保存。 因此 `response.getHeader()`可能返回非字符串值。 但是非字符串值将转换为字符串以进行网络传输。

简单的来说，该方法用于向前端返回数据 并挂起连接

```
request.setHeader("content-type", "text/plain;charset=utf-8");
```

```
request.setHeader('Cookie', ['type=ninja', 'language=javascript']);
```

### response.writeHead()

- `statusCode` ：状态码
- `statusMessage` ：状态信息
- `headers` 请求头对象

向请求发送响应头。 状态码是一个 3 位的 HTTP 状态码，如 `404`。 最后一个参数 `headers` 是响应头。 可以可选地将用户可读的 `statusMessage` 作为第二个参数。

```
const body = 'hello world';
response.writeHead(200, {
  'Content-Length': Buffer.byteLength(body),
  'Content-Type': 'text/plain' });
```

此方法只能在消息上调用一次，并且必须在调用 [response.end()](http://nodejs.cn/s/sqAtet) 之前调用。

如果在调用此方法之前调用了 [response.write()](http://nodejs.cn/s/gvWo3m) 或 [response.end()](http://nodejs.cn/s/sqAtet)，则将计算隐式或可变的响应头并调用此函数。

当使用 [response.setHeader()](http://nodejs.cn/s/rqeM3J) 设置响应头时，则与传给 [response.writeHead()](http://nodejs.cn/s/fnj9oM) 的任何响应头合并，且 [response.writeHead()](http://nodejs.cn/s/fnj9oM) 的优先。

如果调用此方法并且尚未调用 [response.setHeader()](http://nodejs.cn/s/rqeM3J)，则直接将提供的响应头值写入网络通道而不在内部进行缓存，响应头上的 [response.getHeader()](http://nodejs.cn/s/pbE7VN) 将不会产生预期的结果。 如果需要渐进的响应头填充以及将来可能的检索和修改，则改用 [response.setHeader()](http://nodejs.cn/s/rqeM3J)。

### response.write()

- `chunk`块，需要响应的数据内容
- `encoding`：编码， **默认值:** `'utf8'`。
- `callback`
- 返回布尔值

如果调用此方法并且尚未调用 [response.writeHead()](http://nodejs.cn/s/fnj9oM)，则将切换到隐式响应头模式并刷新隐式响应头。

这会发送一块响应主体。 可以多次调用该方法以提供连续的响应主体片段。

注意，在 `http` 模块中，当请求是 HEAD 请求时，则省略响应主体。 同样地， `204` 和 `304` 响应不得包含消息主体。

`chunk` 可以是字符串或 buffer。 如果 `chunk` 是一个字符串，则第二个参数指定如何将其编码为字节流。 当刷新此数据块时将调用 `callback`。

这是原始的 HTTP 主体，与可能使用的更高级别的多部分主体编码无关。

第一次调用 [response.write()](http://nodejs.cn/s/gvWo3m) 时，它会将缓冲的响应头信息和主体的第一个数据块发送给客户端。 第二次调用 [response.write()](http://nodejs.cn/s/gvWo3m) 时，Node.js 假定数据将被流式传输，并分别发送新数据。 也就是说，响应被缓冲到主体的第一个数据块。

如果将整个数据成功刷新到内核缓冲区，则返回 `true`。 如果全部或部分数据在用户内存中排队，则返回 `false`。 当缓冲区再次空闲时，则触发 `'drain'` 事件。

### response.end()

- `data`：块，需要响应的数据内容
- `encoding`：编码，默认 utf-8
- `callback` 
- 返回： `this`

此方法向服务器发出信号，表明已发送所有响应头和主体，该服务器应该视为此消息已完成。 必须在每个响应上调用此 `response.end()` 方法。

如果指定了 `data`，则相当于调用 [response.write(data, encoding)](http://nodejs.cn/s/gvWo3m) 之后再调用 `response.end(callback)`。

如果指定了 `callback`，则当响应流完成时将调用它。

# ==https 模块==

## 1. 概念

HTTPS 是基于 TLS/SSL 的 HTTP 协议。在 Node.js 中，作为一个单独的模块实现。

HTTP服务器，传输过程中都是明文。也就是能够被别人看到。

HTTPS服务器，传输过程中是密文。就算被拦截，只要加密方式不被破解，就不会有损失的风险。

Node中，HTTP模块用于搭建HTTP协议的服务器。

Node中，HTTPS模块用于搭建HTTPS协议的服务器。

HTTPS协议，需要有加密服务，也需要加密文件。这个加密服务最重要的一点是`需要花钱！`，免费的加密服务浏览器会报不安全。

## 2. https.Server 类

此类是 `tls.Server` 的子类，并触发与 [http.Server](http://nodejs.cn/s/jLiRTh) 相同的事件。

- [server.close([callback])](http://nodejs.cn/api/https.html#https_server_close_callback)
- [server.listen()](http://nodejs.cn/api/https.html#https_server_listen)
- [server.maxHeadersCount](http://nodejs.cn/api/https.html#https_server_maxheaderscount)
- [server.headersTimeout](http://nodejs.cn/api/https.html#https_server_headerstimeout)
- [server.setTimeout([msecs\][, callback])](http://nodejs.cn/api/https.html#https_server_settimeout_msecs_callback)
- [server.timeout](http://nodejs.cn/api/https.html#https_server_timeout)
- [server.keepAliveTimeout](http://nodejs.cn/api/https.html#https_server_keepalivetimeout)

# ==url 模块==

## 1. 概念

URL 字符串是结构化的字符串，包含多个含义不同的组成部分。 解析字符串后返回的 URL 对象，每个属性对应字符串的各个组成部分。

`url` 模块提供了两套 API 来处理 URL：一个是旧版本遗留的 API，一个是实现了 [WHATWG标准](http://nodejs.cn/s/fKgW8d)的新 API。

遗留的 API 还没有被废弃，保留是为了兼容已存在的应用程序。 新的应用程序应使用 WHATWG 的 API。

WHATWG 的 API 与遗留的 API 的区别如下。 在下图中，URL `'http://user:pass@sub.example.com:8080/p/a/t/h?query=string#hash'` 上方的是遗留的 `url.parse()` 返回的对象的属性。 下方的则是 WHATWG 的 `URL` 对象的属性。

WHATWG 的 `origin` 属性包括 `protocol` 和 `host`，但不包括 `username` 或 `password`。

![image-20190407191506657](/Users/a1/Library/Application Support/typora-user-images/image-20190407191506657.png)

使用 WHATWG 的 API 解析 URL 字符串：

```
const myURL =
  new URL('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash');
```

使用遗留的 API 解析 URL 字符串：

```
const url = require('url');
const myURL =
  url.parse('https://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash');
```

## 2. 遗留的 URL 对象

遗留的urlObject (`require('url').Url`)由`url.parse()`函数创建并返回。

### url.href

`href` 属性是解析后的完整的 URL 字符串， `protocol` 和 `host` 都会被转换为小写的。

例如：`'http://user:pass@sub.host.com:8080/p/a/t/h?query=string#hash'`

### url.protocol

- 返回：string

获取及设置URL的协议(protocol)部分。

`protocol` 属性表明 URL 的小写的协议体制。

例如：`'http:'`

### url.auth

`auth` 属性是 URL 的用户名与密码部分。 该字符串跟在 `protocol` 和双斜杠（如果有）的后面，排在 `host` 部分的前面且被一个 ASCII 的 at 符号（`@`）分隔。 该字符的格式为 `{username}[:{password}]`， `[:{password}]` 部分是可选的。

例如：`'user:pass'`

### url.host

`host` 属性是 URL 的完整的小写的主机部分，包括 `port`（如果有）。

例如：`'sub.host.com:8080'`

### url.hostname

`hostname` 属性是 `host` 组成部分排除 `port` 之后的小写的主机名部分。

例如：`'sub.host.com'`

### url.port

`port` 属性是 `host` 组成部分中的数值型的端口部分。

例如：`'8080'`

### url.path

`path` 属性是一个 `pathname` 与 `search` 组成部分的串接。

例如：`'/p/a/t/h?query=string'`

不会对 `path` 执行解码。

### url.pathname

`pathname` 属性包含 URL 的整个路径部分。 它跟在 `host` （包括 `port`）后面，排在 `query` 或 `hash` 组成部分的前面且被 ASCII 问号（`?`）或哈希字符（`#`）分隔。

例如：`'/p/a/t/h'`

不会对路径字符串执行解码。

### url.search

`search` 属性包含 URL 的整个查询字符串部分，包括开头的 ASCII 问号字符（`?`）。

例如：`'?query=string'`

不会对查询字符串执行解码。

### url.query

`query` 属性是不含开头 ASCII 问号（`?`）的查询字符串，或一个被 [querystring](http://nodejs.cn/s/i23Gdh) 模块的 `parse()` 方法返回的对象。 `query` 属性是一个字符串还是一个对象是由传入 `url.parse()` 的 `parseQueryString` 参数决定的。

例如：`'query=string'` or `{'query': 'string'}`

如果返回一个字符串，则不会对查询字符串执行解码。 如果返回一个对象，则键和值都会被解码。

###  url.hash

`hash` 属性包含 URL 的碎片部分，包括开头的 ASCII 哈希字符（`#`）。

例如：`'#hash'`

## 3. url.parse()

- `urlString` ：要解析的 URL 字符串。
- `parseQueryString`：如果设为 `true`，则返回的 URL 对象的 `query` 属性会是一个使用 [querystring](http://nodejs.cn/s/i23Gdh) 模块的 `parse()` 生成的对象。 如果设为 `false`，则 `query` 会是一个未解析未解码的字符串。 默认为 `false`。
- `slashesDenoteHost`：如果设为 `true`，则 `//` 之后至下一个 `/` 之前的字符串会解析作为 `host`。 例如， `//foo/bar` 会解析为 `{host: 'foo', pathname: '/bar'}` 而不是 `{pathname: '//foo/bar'}`。 默认为 `false`。

解析 URL 字符串并返回 URL 对象。

如果 `urlString` 不是字符串，则抛出`TypeError`。

如果 `auth` 属性存在但无法解码，则抛出 `URIError`。

## 4. url.format()

- `url Object` 一个 URL 对象（就像 `url.parse()` 返回的）。 如果是一个字符串，则隐式通过 `url.parse()` 转换为一个对象。

`url.format()` 方法返回一个从 `urlObject` 格式化后的 URL 字符串。

如果 `urlObject` 不是一个对象或字符串，则 `url.format()` 抛出 `TypeError`。

格式化过程如下：

- 创建一个新的空字符串 `result`。
- 如果 `urlObject.protocol` 是一个字符串，则它会被原样添加到 `result`。
- 否则，如果 `urlObject.protocol` 不是 `undefined` 也不是一个字符串，则抛出 `Error`。
- 对于不是以 `:` 结束的 `urlObject.protocol`， `:` 会被添加到 `result`。
- 如果以下条件之一为真，则 `//` 会被添加到 `result`：
  - `urlObject.slashes` 属性为真；
  - `urlObject.protocol` 以 `http`、 `https`、 `ftp`、 `gopher` 或 `file` 开头；
- 如果 `urlObject.auth` 属性的值为真，且 `urlObject.host` 或 `urlObject.hostname` 不为 `undefined`，则 `urlObject.auth` 会被添加到 `result`，且后面带上 `@`。
- 如果 `urlObject.host` 属性为 `undefined`，则：
  - 如果 `urlObject.hostname` 是一个字符串，则它会被添加到 `result`。
  - 否则，如果 `urlObject.hostname` 不是 `undefined` 也不是一个字符串，则抛出 `Error`。
  - 如果 `urlObject.port` 属性的值为真，且 `urlObject.hostname` 不为 `undefined`：
    - `:` 会被添加到 `result`。
    - `urlObject.port` 的值会被添加到 `result`。
- 否则，如果 `urlObject.host` 属性的值为真，则 `urlObject.host` 的值会被添加到 `result`。
- 如果 `urlObject.pathname` 属性是一个字符串且不是一个空字符串：
  - 如果 `urlObject.pathname` 不是以 `/` 开头，则 `/` 会被添加到 `result`。
  - `urlObject.pathname` 的值会被添加到 `result`。
- 否则，如果 `urlObject.pathname` 不是 `undefined` 也不是一个字符串，则抛出 `Error`。
- 如果 `urlObject.search` 属性为 `undefined` 且 `urlObject.query` 属性是一个 `Object`，则 `?` 会被添加到 `result`，后面跟上把 `urlObject.query` 的值传入 `querystring`模块的 `stringify()` 方法的调用结果。
- 否则，如果 `urlObject.search` 是一个字符串：
  - 如果 `urlObject.search` 的值不是以 `?` 开头，则 `?` 会被添加到 `result`。
  - `urlObject.search` 的值会被添加到 `result`。
- 否则，如果 `urlObject.search` 不是 `undefined` 也不是一个字符串，则抛出 [`Error`](http://nodejs.cn/s/FLTm19)。
- 如果 `urlObject.hash` 属性是一个字符串：
  - 如果 `urlObject.hash` 的值不是以 `#` 开头，则 `#` 会被添加到 `result`。
  - `urlObject.hash` 的值会被添加到 `result`。
- 否则，如果 `urlObject.hash` 属性不是 `undefined` 也不是一个字符串，则抛出 `Error`。
- 返回 `result`。

# ==querystring 查询字符串模块==

## 1. 概念

`querystring` 模块提供用于解析和格式化 URL 查询字符串的实用工具。 它可以使用以下方式访问：

```
const querystring = require('querystring');
```

## 2. querystring.parse()

- `str` 要解析的 URL 查询字符串。
- `sep`用于在查询字符串中分隔键值对的子字符串。**默认值:** `'&'`。
- `eq`用于在查询字符串中分隔键和值的子字符串。**默认值:** `'='`。
- `options`
  - `decodeURIComponent`  解码查询字符串中的百分比编码字符时使用的函数。**默认值:** `querystring.unescape()`。
  - `maxKeys` 指定要解析的键的最大数量。指定 `0` 可移除键的计数限制。**默认值:** `1000`。

`querystring.parse()` 方法将 URL 查询字符串 `str` 解析为键值对的集合，也就是对象。

例如，查询字符串 `'foo=bar&abc=xyz&abc=123'` 被解析为：

```
{
  foo: 'bar',
  abc: ['xyz', '123']
}
```

`querystring.parse()` 方法返回的对象不是原型继承自 JavaScript `Object`。 这意味着典型的 `Object` 方法如 `obj.toString()`、 `obj.hasOwnProperty()` 等都没有定义并且不起作用。

默认情况下，将假定查询字符串中的百分比编码字符使用 UTF-8 编码。 如果使用其他字符编码，则需要指定其他 `decodeURIComponent` 选项：

```
// 假设 gbkDecodeURIComponent 函数已存在。

querystring.parse('w=%D6%D0%CE%C4&foo=bar', null, null,
                  { decodeURIComponent: gbkDecodeURIComponent });
```

## 3. querystring.stringify()

- `obj`：要序列化为 URL 查询字符串的对象。
- `sep`：  用于在查询字符串中分隔键值对的子字符串。**默认值:** `'&'`。
- `eq` ： 用于在查询字符串中分隔键和值的子字符串。**默认值:** `'='`。
- `options`
  - `encodeURIComponent`：在查询字符串中将 URL 不安全字符转换为百分比编码时使用的函数。**默认值:** `querystring.escape()`。

`querystring.stringify()` 方法通过迭代对象的自身属性从给定的 `obj` 生成 URL 查询字符串。

## 4. querystring.escape()

- `str` ：字符串

`querystring.escape()` 方法以对 URL 查询字符串的特定要求进行了优化的方式对给定的 `str` 执行 URL 百分比编码。

`querystring.escape()` 方法由 `querystring.stringify()` 使用，通常不会直接使用。 它的导出主要是为了允许应用程序代码在必要时通过将 `querystring.escape` 指定给替代函数来提供替换的百分比编码实现。

## 5. querystring.unescape()

- `str`：字符串

`querystring.unescape()` 方法在给定的 `str` 上执行 URL 百分比编码字符的解码。

`querystring.unescape()` 方法由 `querystring.parse()` 使用，通常不会直接使用它。 它的导出主要是为了允许应用程序代码在必要时通过将 `querystring.unescape` 分配给替代函数来提供替换的解码实现。

默认情况下， `querystring.unescape()` 方法将尝试使用 JavaScript 内置的 `decodeURIComponent()` 方法进行解码。 如果失败，将使用更安全的不会丢失格式错误的 URL 的等价方法。

# ==nodeJS 获取数据==

## 1. 获取 GET 请求的数据

该获取方式：URL模块的`parse`方法第二个参数为`true`时，会得到一个`query`对象。该对象就是 `GET`请求提交的数据。

## 2. 获取POST请求的数据

`POST`请求与`GET`不同，它的数据是携带在请求正文中。而不是`QUERY`中。而且数据的量没有上限。

所以，可能会特别的大。无法一次性传递完毕。于是只好分多次发送。

`data` 事件的回调函数参数` data_chunk`: 表示一次发送过来的数据内容，会执行多次，需要进行拼接。`data += data_chunk`

```
req.on("data", function(data_chunk) {
   // data_chunk: 表示一次发送过来的数据内容 
   // 该事件可能会执行多次 视本次发送的数据量的大小
   data += data_chunk
});
req.on("end", function() {
   // end事件只会在发送数据结束后执行一次
});
```

## 3. 数据格式及转换

在 `nodeJS`环境下，前端发送过来的请求数据一般都是字符串格式。fs模块读取文件后，返回的数据默认情况下，一般为`buffer`格式，所以需要将 `buffer`格式数据转为`JSON`字符串，调用 `buf.toString()` 方法即可，这`buf`自带的方法。

```
// 设置文件类型
res.setHeader( "content-type", MimeType[ extension ] + ";charset=utf-8")
res.end( data.toString() )
```

## 4. 获取用户输入的内容

- `输入框`的原生 `js` 方式：

```
<div>
    <label for="">用户名:</label>
    <input type="text">
</div>
<script>
    var input = document.querySelector( "div input" )
    input.onblur = function () {
        console.log( input.value )
    }
</script>
```

- `输入框`的 `jQuery` 方式：

```
$( this ).val()
```

- 全局下弹框的获取方式

```
// 类似于弹出框，提供给用户进行输入
// 一般用变量接收输入
var age = prompt("请输入你的年龄");
```

# ==stream (流)==

## 1. 概念

流（stream）是 Node.js 中处理流式数据的抽象接口。 `stream` 模块用于构建实现了流接口的对象。

Node.js 提供了多种流对象。 例如，[HTTP 服务器的请求](http://nodejs.cn/s/2RqpEw)和 [process.stdout](http://nodejs.cn/s/tQWUzG) 都是流的实例。

流可以是可读的、可写的、或者可读可写的。 所有的流都是 [EventEmitter](http://nodejs.cn/s/pGAddE) 的实例。

使用方法如下：

```
const stream = require('stream')
```

尽管理解流的工作方式很重要，但是 `stream` 模块主要用于开发者创建新类型的流实例。 对于以消费流对象为主的开发者，极少需要直接使用 `stream`模块。

## 2. data 事件

- `chunk `数据块。 对于非对象模式的流， `chunk` 可以是字符串或 `Buffer`。 对于对象模式的流， `chunk` 可以是任何 JavaScript 值，除了 `null`。

当流将数据块传送给消费者后触发。 当调用 `readable.pipe()`， `readable.resume()` 或绑定监听器到 `'data'` 事件时，流会转换到流动模式。 当调用 `readable.read()` 且有数据块返回时，也会触发 `'data'` 事件。

如果使用 `readable.setEncoding()` 为流指定了默认的字符编码，则监听器回调传入的数据为字符串，否则传入的数据为 `Buffer`。

```
const readable = getReadableStreamSomehow();
readable.on('data', (chunk) => {
  console.log(`接收到 ${chunk.length} 个字节的数据`);
});
```

## 3. end 事件

当流中没有数据可供消费时触发。

`'end'` 事件只有在数据被完全消费掉后才会触发。 要想触发该事件，可以将流转换到流动模式，或反复调用 [stream.read()](http://nodejs.cn/s/SpgRaa) 直到数据被消费完。

```
const readable = getReadableStreamSomehow();
readable.on('data', (chunk) => {
  console.log(`接收到 ${chunk.length} 个字节的数据`);
});
readable.on('end', () => {
  console.log('已没有数据');
});
```

# ==nodemon 模块==

## 1. 概念

`nodemon`是`node`的一个调试工具模块。当我们修改了后台`node`服务器的代码之后，都需要重启`node`服务器。我们可以使用`nodemon`来`自动重启服务`。

## 2. 安装

此模块需要`npm`全局安装，加上`-g`全局下载：

```
npm install -g nodemon
```

若`mac`安装`nodemon`失败，说明没有权限。

需要先卸载，再重新安装，安装时加上`sudo 命令`即可：

- `npm uninstall nodemon `。 window 卸载 modemon 模块
- `sudo npm uninstall -g nodemon`。 mac 卸载 modemon 模块
- `sudo npm install -g --force nodemon` 。 Mac 方式安装 modemon 模块

## 3. 通过 nodemon 启动服务器

- `nodemon server.js`

使用此命令启动服务器，则在修改代码后可自己重启服务。

- `nodemon rs`

此命令，则是手动重启服务器

# ==Express 模块==

## 1. 概述

Express是一个`NodeJS`的`服务器框架`。

可以快速的开发服务器相关内容。极大地简化了之前的繁琐的操作。比如获取`post`数据、拆分路由。

官网：http://www.expressjs.com.cn/

下载：

```
npm install express --save
```

## 2. 搭建服务器

```
var express = require("express");
var app = express();
app.listen(3000);
```

## 3. app.VERB()

`app.VERB() `指的是一类方法，也是路由器的格式，具体的方法有 `app.get(path, handler) `、`app.put(path, handler) `等，当然还有 `app.all()`。

## 4. Router 对象

`router`目的是中间件和路由的分离的实例。您可以将其视为“迷你应用程序”，只能执行中间件和路由功能。每个Express应用程序都有一个内置的应用程序路由器。

路由器的行为类似于中间件本身，因此您可以将其用作 [app.use（）](http://www.expressjs.com.cn/4x/api.html#app.use)的参数或作为另一个路由器的[use（）](http://www.expressjs.com.cn/4x/api.html#router.use)方法的参数。

顶级`express`对象具有一个用于创建新对象的[Router（）](http://www.expressjs.com.cn/4x/api.html#express.router)方法`router`。

一旦你创建了一个路由器的对象，你可以添加中间件和HTTP方法路由（如`get`，`put`，`post`，等），以它就像一个应用程序。例如：

```
// invoked for any requests passed to this router
router.use(function(req, res, next) {
  // .. some logic here .. like any other middleware
  next();
});

// will handle any request that ends in /events
// depends on where the router is "use()'d"
router.get('/events', function(req, res, next) {
  // ..
});
```

然后，您可以使用路由器来处理特定的根URL，从而将路由分成文件甚至是迷你应用程序。

```
// only requests to /calendar/* will be sent to our "router"
app.use( router );
```

## 5. 使用中间件

```
app.use(path, fun)
```

`app.use()`方法用于使用中间件。

- 第一个参数：表示访问的路由前缀，路径映射，可以是正则
- 第二个参数表示处理函数

## 6. 静态中间件

之前我们介绍过，所有的请求都可以分为两类：静态资源、接口（路由）

静态资源都是一些文件：html、css、js、png等

`Express`提供了静态中间件处理静态文件，该中间件是唯一`内置`的中间件。其他中间件已经被分离出去需要下载

```
// 静态中间件
app.use("/web/", express.static("./web"));
```

`static`方法的参数是一个 `base 路径`。`app.use`方法第一个参数是映射这个`base路径`去显示在` URL`中

## 7. 匹配GET接口并获取数据

匹配接口，在服务器这边也可以叫做路由。`Route`。

匹配路由的方式分为两种：

第一种： `app.get(path, callback)` 

- `path`:：接口的地址字符串
- `callback`： 对应的处理函数
  - `req`：依旧是前端请求对象，但是 Express 对原生的对象做了增强。比如：`req.query`。该属性是本次的URL中的query字符串解析完毕之后的对象。
  - `res`：依旧是后端响应对象，同样的 Express 对它做了增强。比如：`res.send()`; 该方法用于返回数据并挂起连接。而且会在发送时，自动转为字符串形式

```
app.get("/checkName", function(req, res) {
	console.log("前端发送请求检测用户名了");
	console.log(req.query);
})
```

![image-20190419043750549](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/koxuk.png)

## 8. 匹配POST接口并获取数据

之前在原生中，获取数据的时候要监听`data`事件与`end`事件。还要额外定义变量，拼接，还要引入`querystring`模块，将拼接好的字符串转为`query对象`。太过麻烦。

`express`框架提供`body-parser` 中间件，一旦应用该中间件，该条代码之后的所有普通`post请求`都可以通过`req.body`获取数据。

```
// 处理POST请求
app.post("/login", function(req, res) {
	console.log("前端发送请求登录");
	console.log(req.body);
});
```

### body-parser 中间件

引入后能够通过`req.body`直接获取 post 接口请求的携带数据。没有引入`body-parser` 中间件的话，使用`req.body`值会是`undefined`

- 下载：

```
npm install body-parser --save
```

- 使用：

```
// 使用body-parser中间件
app.use(body_parser.urlencoded({extended: false}));
```

- 案例：

```
// 引入express
var express = require("express");
// 引入body-parser 该模块用于获取前端提交的普通post请求的数据 解析完毕之后挂载在req.body上
var body_parser = require("body-parser");
// 生成服务器对象
var app = express();

// 使用body-parser中间件
app.use(body_parser.urlencoded({extended: false}));
// 静态化
app.use("/web/", express.static("./web"));
// 处理GET请求
app.get("/checkName", function(req, res) {
	console.log("前端发送请求检测用户名了");
	console.log(req.query);
	res.send({
		error: 0,
		data: "用户名可以使用"
	});
});

// 处理POST请求
app.post("/login", function(req, res) {
	console.log("前端发送请求登录");
	console.log(req.body);
});
// 监听端口号
app.listen(3000);
```

# ==上传文件处理模块==

## 1. 概述

我们可以自己写，也可以使用现有的模块。

该模块专门用于处理文件上传：`formidable`

- 下载：

```
npm install formidable --save
```

## 2. 处理流程

- 第一步：初始化解析对象

```
// 引入 formidable
var formidable = require("formidable")

// 初始化 formidable
var form = new formidable()
```

- 第二步：设置上传路径，其实是文件上传后保存的位置

```
 form.uploadDir = "./cache"
```

- 第三步：解析操作（改文件名）：

```
form.parse(req, function(err, fields, files) {
	console.log(err);  表示错误信息
	console.log(fields);  fields 表示文本区域的内容 
	console.log(files);  files 表示文件区域的内容 它的某一个属性才是某个文件的信息
})
```

## 3. parse() 方法

`form.parse( req, function ( err, fields, files ) )`

- req： 未知
- function ：回调函数
  - `err`： 错误信息
  - `fields`： 表示整个表单的文本内容大对象，不包含文件。以`field`对象的形式存在
  - `files`：表示文件大对象，里面每一个成员都是文件，也是以`file`对象的形式存在

![image-20190419050941721](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/e9euc.png)

## 4. field事件、file 事件

`formidable`在解析内容的时候，是先解析文本，再解析文件。如果文件不止一个，则需要一个一个的解析.

解析文本时，一个表单控件发出的请求数据触发一次`field`事件

解析文件时，一个文件内容触发一次`file`事件

```
// 监听file事件
form.on("file", function(key, value) {
	arr.push(value);
});
```

- `key`：`file `对象的名字
- `value`：`file`对象的值

## 5. 单文件改名

```
// 搭建服务器
var express = require("express");
var app = express();
// 引入formidable
var formidable = require("formidable");
// 引入fs
var fs = require("fs");

// 静态化
app.use("/web/", express.static("./web"));

// 匹配/uploadFile接口
app.post("/uploadFile", function(req, res) {
	// 在对应的路由中去使用formidable
	var form = new formidable();
	// 设置上传路径
	form.uploadDir = "./cache";
	// 开始解析
	form.parse(req, function(err, fields, files) {
		// 判定解析过程是否出错
		if (err) {
			// 如果有问题 就返回信息给前端
			res.send("抱歉，文件上传失败");
			return;
		}
		console.log(fields);
		// 获取原来的文件名
		var oldName = files.ickt_file.name;
		// 获取现在的路径
		var oldPath = files.ickt_file.path;
		// 定义新的路径
		var newPath = "./cache/" + oldName;
		// 重命名
		fs.rename(oldPath, newPath, function(err) {
			if (err) {
				// 出错了
				res.send("改名失败");
				return;
			}
			res.send("文件上传成功");
		});
	});
});

// 监听端口号
app.listen(3000);
```

## 6. 多文件改名

```
// 搭建服务器
var express = require("express");
var app = express();
// 引入formidable
var formidable = require("formidable");
// 引入fs
var fs = require("fs");

// 静态化
app.use("/web/", express.static("./web"));

// 匹配/uploadFile接口
app.post("/uploadFile", function(req, res) {
	// formidable 在解析内容的时候，是先解析文本，再解析文件。如果文件不止一个，则需要一个一个的解析。
	// 其实有两个事件 field 事件 file 事件
	// 每解析完一张图片都会触发一次file 事件 
	// field 事件与file 事件都是parse的一部分


	// 在对应的路由中去使用formidable
	var form = new formidable();
	// 设置上传路径
	form.uploadDir = "./cache";
	// 定义一个数组
	var arr = [];
	// 监听file事件
	form.on("file", function(key, value) {
		arr.push(value);
	});
	// 开始解析
	form.parse(req, function(err, fields, files) {
		// 判定解析过程是否出错
		if (err) {
			// 如果有问题 就返回信息给前端
			res.send("抱歉，文件上传失败");
			return;
		}
		// 在这里使用arr 
		try {
			for (var i = 0; i < arr.length; i++) {
				var oldPath = arr[i].path;
				var newPath = "./cache/" + arr[i].name;
				fs.renameSync(oldPath, newPath);
			}
		}
		catch(e) {
			console.log(123, e);
			res.send("出错了，" + JSON.stringify(e));
			return;
		}
		res.send("所有图片都处理完毕");
	});
});
// 监听端口号
app.listen(3000);
```

## 7. try……catch 语句

该语句用于控制异常。

如果同步代码出现错误。则浏览器或者服务器会崩溃。为了防止这样的情况的发生，我们最好在可能出现异常代码附近，使用try语句包裹。

使用 `try……catch 语句`后，即使报错，不影响后面代码的执行

```
try {
   可能出错的代码
}
catch(e) {
   e就表示try中的代码出错时的错误信息
}
```

# ==服务器返回类型==

## 1. 概述

因为检测用户名只合适使用AJAX发送（不刷新页面），所以，后台无论如何只能够返回JSON格式的数据。

登录和注册既可以使用表单提交，又可以使用AJAX提交。

此时，服务器开发者就应当分辨提交的方式。到底是表单还是AJAX。

如果是表单提交，因为前端的表单会清空当前页面的内容，而登录又需要看到登录后的内容。所以，后台应当返回一个页面。

如果是AJAX提交，因为AJAX不会刷新当前页面，所以，返回页面就不可行，应当返回一个JSON。让前端在AJAX回调函数中进行判定，并跳转页面。

## 2. 判断请求类型

`req.xhr`

此属性是`express`模块的内置属性，必须先引入`express`模块才能使用。

一个布尔属性，`true`如果请求头的`X-Requested-With`字段是`“XMLHttpRequest”`，则表示该请求是由客户端库（如`jQuery`或者`Ajax`）发出的。

```
req.xhr
// => true
```

## 3. 总结

如果前端发送的是表单、a标签请求，则后台需要返回页面。

如果前端发送的是AJAX，则后台需要返回JSON

# ==Cookie==

## 1. 概述

Cookie 是服务器保存在浏览器的一小段文本信息，每个 Cookie 的大小一般不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。详见《浏览器对象模型 - Cookie》

Cookie 主要用来分辨两个请求是否来自同一个浏览器，以及用来保存一些状态信息。它的常用场合有以下一些。

- 对话（session）管理：保存登录、购物车等需要记录的信息。
- 个性化：保存用户的偏好，比如网页的字体大小、背景色等等。
- 追踪：记录和分析用户行为。

不同浏览器对 Cookie 数量和大小的限制，是不一样的。一般来说，单个域名设置的 Cookie 不应超过30个，每个 Cookie 的大小不能超过4KB。超过限制以后，Cookie 将被忽略，不会被设置。

浏览器的同源政策规定，两个网址只要域名相同和端口相同，就可以共享 Cookie 。参见《同源政策》。注意，这里不要求协议相同。也就是说，`http://example.com`设置的 Cookie，可以被`https://example.com`读取。

## 2. Cookie 构成

Cookie 包含以下几方面的信息。

- Cookie 的名字
- Cookie 的值（真正的数据写在这里面）
- 到期时间
- 所属域名（默认是当前域名）
- 生效的路径（默认是当前网址）

举例来说，用户访问网址`www.example.com`，服务器在浏览器写入一个 Cookie。这个 Cookie 就会包含`www.example.com`这个域名，以及根路径`/`。这意味着，这个 Cookie 对该域名的根路径和它的所有子路径都有效。如果路径设为`/forums`，那么这个 Cookie 只有在访问`www.example.com/forums`及其子路径时才有效。以后，浏览器一旦访问这个路径，浏览器就会附上这段 Cookie 发送给服务器。

## 3. 生成过程

当登录时，用户填写完毕表单内容，并点击提交。

HTTP请求就发送到服务器。

服务器接收到本次请求，接口程序开始运行。经过检测用户提交的名称密码等信息（与数据库对比）。确定可以登录。

于是服务器在响应头中设置一个set-cookie字段，并设置一些值在里面，这些值就是用户的相关信息。

处理完毕，将信息返回给前端后，关闭连接。

浏览器接收到后端返回的数据，发现有一个set-cookie响应头，于是生成cookie文件并保存在浏览器文件夹下。

之后的每一次向同一个服务器发送的请求，都会将该 cookie 携带过去，读取文件内容并放在请求头的cookie 中。

服务器通过检测请求头中的cookie字段获取之前设置过的内容，从而分辨用户身份。

## 4. nodeJS 设置 Cookie

服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个`Set-Cookie`字段。

Node中，天生就可以设置cookie

```
res.setHeader("set-cookie", "一般是用户数据")
```

## 5. Express 框架设置 Cookie

Express中，给 node 操控 Cookie 做了优化

`res.cookie(key, value, options)`

- `key`：cookie 的 name
- `value`：key 对应的值，真正的数据放在里面
- `options`：配置对象 该对象用于控制cookie的相关内容
  - `maxAge`：从设置开始 多少毫秒之后 cookie 失效
  - `httpOnly`：是否允许前端通过脚本控制 cookie
  - `domain`：cookie 发往的域名默认是服务器本身
  - `path`：cookie 发往的路径 默认是 "/" 
  - `secure`：是否只允许 https 协议

**（1）登录之前：请求头中并没有任何与Cookie有关的内容**

![image-20190419060932706](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/ljzea.png)

**（2）登录之后：后端的执行代码，本次响应头中存在`set-cookie`**

```
app.post("/login", function(req, res) {
	res.cookie("username", "wnaglaowu", {} );
	res.cookie("password", "123456", {} );
	res.send("登录成功");
});
```

![image-20190419061100327](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/bx2j8.png)

**（3）登录之后的下一次请求：请求头中就具备了`cookie`了**

![image-20190419061224731](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/hrd98.png)

**（5）后端获取 cookie**

```
// 检测 cookie 接口
app.get("/checkCookie", function(req, res) {
	var query = querystring.parse(req.headers.cookie, "; ", "=");
	console.log(query, "人工格式化");
});
```

![image-20190419062322155](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/zkenb.png)

### cookie-parser中间件

`cookie-parser`中间件，用于将前端浏览器提交上来的`cookie字符串格式`转化为对象，并挂载在req身上。

- 下载：

```
npm install cookie-parser --save
```

- 使用：

```
var cookie = require("cookie-parser");
app.use(cookie());

// 检测cookie接口
app.get("/checkCookie", function(req, res) {
	console.log(req.cookies, "cookie-parser中间件");
});
```

![image-20190419062633376](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/f12hd.png)

# ==Session==

## 1. 概念

session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。

 当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此客户端创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。

经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。

还有一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。比如：

```
<form name="testform" action="/xxx"> 
	<input type="hidden" name="jsessionid" value="ByOK3vjFD75aPnrnLerj!-145788764"> 
	<input type="text"> 
</form> 
```

## 2. Session 运行机制

当服务器启动时，session生成。

当登录时，用户填写完毕表单内容，并点击提交。

HTTP请求就发送到服务器。

服务器接收到本次请求，接口程序开始运行。经过检测用户提交的名称密码等信息。确定可以登录。

服务器将用户的相关信息放入session。session生成一个唯一随机字符串。该随机字符串与用户的数据绑定。session可以根据该随机字符串找到用户的信息。

服务器将该随机字符串设置到set-cookie中。并返回数据给浏览器。关闭连接。

浏览器接收到数据，查看到set-cookie。于是生成cookie文件。保存下来。

下一次请求时，将对应的cookie文件读取，并设置在请求头的cookie字段。发送到服务器端。服务器端检测到cookie中的随机字符串。于是找到对应的用户信息。确定用户身份。

##4. Express 框架设置 Session

只要下载并配置一个中间件：`express-session`。之后就可以在任意的接口中通过`req.session.xxx `读取 session 中的内容；通过`req.session.xxx = `设置 session 中的内容

### express-session 中间件

- `session(options)`其中 options 中包含可选参数，主要有：
  - `name`: 设置 cookie 中，保存 session 的字段名称，默认为 `connect.sid` 。
  - `store`: session 的存储方式，默认存放在内存中，也可以使用 redis，mongodb 等。express 生态中都有相应模块的支持。
  - `secret`: 通过设置的 secret 字符串，来计算 hash 值并放在 cookie 中，使产生的 signedCookie 防篡改。
  - `cookie`: 设置存放 session id 的 cookie 的相关选项，默认为
    - (default: { path: '/', httpOnly: true, secure: false, maxAge: null })

  - `genid`: 产生一个新的 session_id 时，所使用的函数， 默认使用 `uid2` 这个 npm 包。
  - `rolling`: 每个请求都重新设置一个 cookie，默认为 false。
  - `resave`: 即使 session 没有被修改，也保存 session 值，默认为 true。

- **下载**：

```
npm install express-session
```

- **配置**：

```
// 配置session中间件
app.use(session({
	secret: "adsfewaffewfewafpoewafoiefoieahfoiehoifhewoifhehfoiehfoihewoifhehfoiahewoifhehfoihewoifhoiefhoa",
	resave: false,
	saveUninitialized: false
}));
```

- **设置 session：一般在第一次登陆时设置**

```
// 登录接口
app.post("/login", function(req, res) {
	// 当登录时, 且与数据库进行了对比，用户名和密码正确后，将正确的数据设置到session中
	req.session.username = "wanglaowu";
	req.session.password = "123";
	
	res.send("ok");
});
```

`请求头中（登录之前）`：没有任何与 Cookie 相关内容

![image-20190427131621472](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/m20jo.png)

`响应头中（第一次登陆）`：后台设置一个set-cookie

![image-20190427131744496](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/wxk7k.png)

`请求头中（后面的登陆）`：cookie 就被每一次请求携带

![image-20190427131847096](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/26rqp.png)

- **检测 Session 接口**：

```
// 检测 session 接口
app.get("/checkSession", function(req, res) {
	// 当访问本接口时 输出服务器端的session
	console.log(req.session);
});
```

`req.session`输出（登陆前）：没有用户相关的数据

![image-20190427125116734](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/4uhjv.png)

`req.session`输出（登陆后）：多了两条与用户相关的数据

![image-20190427130141009](http://markdown-3.oss-cn-beijing.aliyuncs.com/a/w7w1t.png)



## 4. Session 持久化

Session是随着服务器的开启而生成，随着服务器的关闭而销毁。

我们在调试代码的时候，就很不方便。每一次修改了服务器的代码都需要重新登录。

所以，我们现在将session存储到数据库中，也就是`“session持久化”`。

### connect-mongo 模块

该模块可以将session中的数据，在服务器销毁的时候，存储到数据库中，在服务器打开的时候，再将这些数据从数据库中提取出来，放到新生成的session中。

- 下载：

```
npm install connect-mongo --save
```

- 配置：

```
var express = require("express");
// 引入body-parser
var body_parser = require("body-parser");
// 引入session
var session = require("express-session");
// 引入connect-mongo 
var connect = require("connect-mongo");
// 初始化存储对象
0var MongoStore = connect(session);

// 暴露一个函数出去 该函数用于配置服务器
module.exports = function(app) {
	app.use("/web/", express.static("./web"));
	app.use("/albums/", express.static("./albums"));
	app.use(body_parser.urlencoded({extended: false}));
	app.use(session({
		secret: "afehoiewahfasdfpewjfpoewajfpojewapofjewapojfpoewajfpojewapfjaewpo",
		resave: false,
		saveUninitialized: true,
		store: new MongoStore({url: "mongodb://localhost:27017/session"})
	}));
}
```

# ==后端模板==

## 1. 原生后端渲染

用户登录之后，通常会显示用户的名称。那么显示用户名称的页面，是一个模板页面。这是通过后端响应返回的。

```
// 登录接口
app.post("/login", function(req, res) {
	// 当登录时 访问session
	req.session.username = req.body.username;
	req.session.password = req.body.password;
	// 显示欢迎页面给用户
	// 读取./web/welcome.aaa的内容 然后格式化 格式化的过程就是将<%%>替换掉的过程
	fs.readFile("./web/welcome.aaa", function(err, data) {
		var result = data.toString().replace("<%username%>", req.session.username);
		res.setHeader("content-type", "text/html;charset=utf-8");
		res.send(result);
	});
});
```

上面代码的方法有一些缺陷，没有下面的 EJS 模板高级，比如： EJS 模板中可以是JS执行环境。

## 2. EJS 模板

`EJS`是可以与Express搭配的一套后端模板工具。ejs模板天生就可以与Express搭配使用 不需要配置

- 下载：

```
npm install ejs --save
```

- 应用

```
// 登录接口
app.post("/login", function(req, res) {
	// 当登录时 访问session，这里代码的作用是修改 session 内的数据。
	req.session.username = req.body.username;
	req.session.password = req.body.password;
	// 显示欢迎页面给用户
	res.render("path", {
		username: req.session.username
	});
});
```

## 2. res.render()

`res.render`方法用于渲染模板，其实就是将上面的

- 第一个参数表示模板所在  默认从`views`之后开始书写

- 第二个参数表示字典对象  该字典对象必须具备模板中的每一个变量

## 3. EJS 规则

所有模板文件的后缀名都必须为:` ejs`

所有模板文件都必须存放在`views`目录下

插值方式：` <%=xxx%>`，必出必须有 `=`号

`<%%>`之间是一个JS环境，可以调用任何的JS方法、使用任何的JS语法。

所有的`<%%>`共用同一个作用域。 
